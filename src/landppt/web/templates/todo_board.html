{% extends "base.html" %}

{% block title %}TODO çœ‹æ¿ - {{ todo_board.title }} - LandPPT{% endblock %}

{% block extra_css %}
<style>
/* Outline view specific styles */
.outline-card {
    transition: all 0.3s ease;
}

.outline-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

.slide-number {
    background: #3498db;
    color: white;
    border-radius: 50%;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.8em;
    font-weight: bold;
}

.slide-number.large {
    width: 32px;
    height: 32px;
    font-size: 1em;
}

.slide-type-tag {
    background: #e8f4fd;
    color: #3498db;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 0.8em;
}

.content-points {
    margin: 0;
    padding-left: 20px;
    color: #555;
    line-height: 1.6;
}

.content-points li {
    margin-bottom: 5px;
}

/* Modal styles */
.modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
}

/* Button hover effects */
.btn:hover {
    opacity: 0.9;
    transform: translateY(-1px);
}

/* Animation for loading states */
@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* è„‰å†²åŠ¨ç”» */
@keyframes pulse {
    0% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.1); opacity: 0.7; }
    100% { transform: scale(1); opacity: 1; }
}

/* æ³¢æµªåŠ¨ç”» */
@keyframes wave {
    0%, 60%, 100% { transform: initial; }
    30% { transform: translateY(-15px); }
}

/* æ¸å˜èƒŒæ™¯åŠ¨ç”» */
@keyframes gradientShift {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

/* æ‰“å­—æœºæ•ˆæœ */
@keyframes typing {
    from { width: 0; }
    to { width: 100%; }
}

/* é—ªçƒå…‰æ ‡ */
@keyframes blink {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0; }
}

/* è¿›åº¦æ¡åŠ¨ç”» */
@keyframes progressBar {
    0% { width: 0%; }
    25% { width: 30%; }
    50% { width: 60%; }
    75% { width: 85%; }
    100% { width: 100%; }
}

/* æµ®åŠ¨åŠ¨ç”» */
@keyframes float {
    0%, 100% { transform: translateY(0px); }
    50% { transform: translateY(-10px); }
}

/* ç­‰å¾…åŠ¨ç”»å®¹å™¨æ ·å¼ */
.loading-container {
    text-align: center;
    padding: 30px 20px;
    background: linear-gradient(-45deg, #f8f9fa, #e9ecef, #f8f9fa, #e9ecef);
    background-size: 400% 400%;
    animation: gradientShift 4s ease infinite;
    border-radius: 15px;
    margin: 15px 0;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    max-height: 500px;
    overflow: hidden;
}

.loading-icon {
    font-size: 2.5em;
    color: #3498db;
    margin-bottom: 15px;
    animation: pulse 2s ease-in-out infinite;
}

.loading-title {
    font-size: 1.2em;
    font-weight: 600;
    color: #2c3e50;
    margin-bottom: 10px;
}

/* åˆ›æ„AIå¤§è„‘æ€è€ƒåŠ¨ç”» */
.brain-container {
    display: flex;
    justify-content: center;
    align-items: center;
    margin: 20px 0;
    height: 180px;
    perspective: 1000px;
    position: relative;
}

.ai-brain {
    position: relative;
    width: 120px;
    height: 120px;
    animation: brainFloat 4s ease-in-out infinite;
}

@keyframes brainFloat {
    0%, 100% {
        transform: translateY(0px) scale(1);
    }
    50% {
        transform: translateY(-10px) scale(1.05);
    }
}

.brain-core {
    position: absolute;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
    border-radius: 50%;
    box-shadow: 0 8px 32px rgba(102, 126, 234, 0.3);
    overflow: hidden;
}

.brain-core::before {
    content: '';
    position: absolute;
    top: 20%;
    left: 20%;
    width: 60%;
    height: 60%;
    background: radial-gradient(circle, rgba(255,255,255,0.2) 0%, transparent 70%);
    border-radius: 50%;
    animation: brainPulse 2s ease-in-out infinite;
}

@keyframes brainPulse {
    0%, 100% {
        opacity: 0.3;
        transform: scale(1);
    }
    50% {
        opacity: 0.7;
        transform: scale(1.1);
    }
}

.brain-icon {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 48px;
    color: white;
    text-shadow: 0 2px 10px rgba(0,0,0,0.3);
    animation: iconGlow 3s ease-in-out infinite;
}

@keyframes iconGlow {
    0%, 100% {
        text-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }
    50% {
        text-shadow: 0 2px 20px rgba(255,255,255,0.5), 0 0 30px rgba(102, 126, 234, 0.8);
    }
}

/* æ€ç»´è¿æ¥çº¿åŠ¨ç”» */
.neural-network {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
}

.neural-line {
    position: absolute;
    background: linear-gradient(90deg, transparent 0%, rgba(102, 126, 234, 0.6) 50%, transparent 100%);
    border-radius: 2px;
    opacity: 0;
    animation: neuralPulse 3s ease-in-out infinite;
}

.neural-line:nth-child(1) {
    top: 30%;
    left: -20%;
    width: 60px;
    height: 2px;
    transform: rotate(45deg);
    animation-delay: 0s;
}

.neural-line:nth-child(2) {
    top: 60%;
    right: -20%;
    width: 50px;
    height: 2px;
    transform: rotate(-30deg);
    animation-delay: 0.5s;
}

.neural-line:nth-child(3) {
    bottom: 20%;
    left: -15%;
    width: 45px;
    height: 2px;
    transform: rotate(-45deg);
    animation-delay: 1s;
}

.neural-line:nth-child(4) {
    top: 20%;
    right: -15%;
    width: 55px;
    height: 2px;
    transform: rotate(60deg);
    animation-delay: 1.5s;
}

@keyframes neuralPulse {
    0%, 70% {
        opacity: 0;
        transform: scale(0.5) rotate(var(--rotation, 0deg));
    }
    10%, 60% {
        opacity: 1;
        transform: scale(1) rotate(var(--rotation, 0deg));
    }
    100% {
        opacity: 0;
        transform: scale(0.5) rotate(var(--rotation, 0deg));
    }
}

/* æ€è€ƒæ°”æ³¡åŠ¨ç”» */
.thought-bubbles {
    position: absolute;
    top: -20px;
    left: 50%;
    transform: translateX(-50%);
    width: 200px;
    height: 60px;
}

.thought-bubble {
    position: absolute;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 50%;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    opacity: 0;
    animation: bubbleFloat 4s ease-in-out infinite;
}

.thought-bubble:nth-child(1) {
    width: 12px;
    height: 12px;
    bottom: 0;
    left: 45%;
    animation-delay: 0s;
}

.thought-bubble:nth-child(2) {
    width: 18px;
    height: 18px;
    bottom: 15px;
    left: 35%;
    animation-delay: 0.3s;
}

.thought-bubble:nth-child(3) {
    width: 24px;
    height: 24px;
    bottom: 35px;
    left: 25%;
    animation-delay: 0.6s;
}

@keyframes bubbleFloat {
    0%, 80% {
        opacity: 0;
        transform: translateY(20px) scale(0.5);
    }
    10%, 70% {
        opacity: 1;
        transform: translateY(0px) scale(1);
    }
    100% {
        opacity: 0;
        transform: translateY(-10px) scale(0.8);
    }
}

/* è¿›åº¦ç¯åŠ¨ç”» */
.progress-ring {
    position: absolute;
    top: -10px;
    left: -10px;
    width: 140px;
    height: 140px;
}

.progress-ring-circle {
    fill: none;
    stroke: rgba(102, 126, 234, 0.3);
    stroke-width: 3;
    stroke-linecap: round;
    transform-origin: 50% 50%;
    transform: rotate(-90deg);
    animation: progressRotate 8s linear infinite;
}

.progress-ring-progress {
    fill: none;
    stroke: #667eea;
    stroke-width: 3;
    stroke-linecap: round;
    stroke-dasharray: 440;
    stroke-dashoffset: 440;
    transform-origin: 50% 50%;
    transform: rotate(-90deg);
    animation: progressFill 8s ease-in-out infinite;
}

@keyframes progressRotate {
    0% {
        transform: rotate(-90deg);
    }
    100% {
        transform: rotate(270deg);
    }
}

@keyframes progressFill {
    0%, 20% {
        stroke-dashoffset: 440;
    }
    80%, 100% {
        stroke-dashoffset: 0;
    }
}

/* æ–‡å­—ç”Ÿæˆæ•ˆæœ */
.text-generation {
    position: absolute;
    bottom: -40px;
    left: 50%;
    transform: translateX(-50%);
    width: 200px;
    text-align: center;
}

.generating-text {
    color: #667eea;
    font-size: 14px;
    font-weight: 600;
    margin-bottom: 8px;
    opacity: 0;
    animation: textFade 4s ease-in-out infinite;
}

.generating-dots {
    color: #667eea;
    font-size: 16px;
    letter-spacing: 2px;
    animation: dotsAnimation 2s ease-in-out infinite;
}

@keyframes textFade {
    0%, 20% {
        opacity: 0;
        transform: translateY(10px);
    }
    30%, 70% {
        opacity: 1;
        transform: translateY(0px);
    }
    80%, 100% {
        opacity: 0;
        transform: translateY(-10px);
    }
}

@keyframes dotsAnimation {
    0%, 20% {
        opacity: 0.3;
    }
    50% {
        opacity: 1;
    }
    100% {
        opacity: 0.3;
    }
}

/* å®ŒæˆçŠ¶æ€åŠ¨ç”» */
.ai-brain.completed {
    animation: brainComplete 2s ease-out forwards;
}

.ai-brain.completed .brain-core {
    background: linear-gradient(135deg, #27ae60 0%, #2ecc71 50%, #58d68d 100%);
    animation: completionGlow 1.5s ease-out;
}

.ai-brain.completed .brain-icon::before {
    content: 'âœ“';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 32px;
    color: white;
    animation: checkmarkAppear 1s ease-out;
}

@keyframes brainComplete {
    0% {
        transform: translateY(0px) scale(1);
    }
    50% {
        transform: translateY(-20px) scale(1.2);
    }
    100% {
        transform: translateY(-5px) scale(1.1);
    }
}

@keyframes completionGlow {
    0% {
        box-shadow: 0 8px 32px rgba(102, 126, 234, 0.3);
    }
    50% {
        box-shadow: 0 12px 48px rgba(39, 174, 96, 0.6);
    }
    100% {
        box-shadow: 0 10px 40px rgba(39, 174, 96, 0.4);
    }
}

@keyframes checkmarkAppear {
    0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.3);
    }
    50% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.3);
    }
    100% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
}

.progress-container {
    width: 100%;
    height: 6px;
    background: #e9ecef;
    border-radius: 3px;
    margin: 20px 0;
    overflow: hidden;
}

.progress-bar {
    height: 100%;
    background: linear-gradient(90deg, #3498db, #2ecc71);
    border-radius: 3px;
    animation: progressBar 15s ease-in-out infinite;
}

.loading-tips {
    margin-top: 20px;
    padding: 12px;
    background: rgba(52, 152, 219, 0.1);
    border-radius: 8px;
    border-left: 4px solid #3498db;
}

.loading-tips h5 {
    color: #2c3e50;
    margin-bottom: 8px;
    font-size: 1em;
}

.loading-tips p {
    color: #666;
    margin: 0;
    font-size: 0.9em;
    line-height: 1.4;
}

@keyframes blink {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0; }
}

/* è¡¨å•ç¾åŒ– */
.form-group {
    margin-bottom: 25px;
}

.form-group label {
    display: block;
    margin-bottom: 8px;
    color: #2c3e50;
    font-weight: 600;
    font-size: 14px;
}

.form-group input,
.form-group select,
.form-group textarea {
    width: 100%;
    padding: 12px 16px;
    border: 2px solid #e9ecef;
    border-radius: 10px;
    font-size: 14px;
    transition: all 0.3s ease;
    background: white;
}

.form-group input:focus,
.form-group select:focus,
.form-group textarea:focus {
    outline: none;
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    transform: translateY(-1px);
}

/* æŒ‰é’®ç¾åŒ– */
.btn {
    padding: 12px 24px;
    border-radius: 10px;
    font-weight: 600;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    border: none;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 8px;
    text-decoration: none;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
}

.btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0,0,0,0.15);
}

.btn-primary {
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
}

.btn-success {
    background: linear-gradient(135deg, #27ae60, #229954);
    color: white;
}

.btn-outline-primary {
    background: transparent;
    color: #667eea;
    border: 2px solid #667eea;
}

.btn-outline-primary:hover {
    background: #667eea;
    color: white;
}

.btn-secondary {
    background: linear-gradient(135deg, #95a5a6, #7f8c8d);
    color: white;
}

/* å°å°ºå¯¸æŒ‰é’® */
.btn-sm {
    padding: 8px 16px;
    font-size: 13px;
    gap: 6px;
}

.btn-xs {
    padding: 6px 12px;
    font-size: 12px;
    gap: 4px;
}

/* å¤§çº²ç›¸å…³æŒ‰é’®æ ·å¼ */
.btn-outline-warning {
    background: transparent;
    color: #f39c12;
    border: 2px solid #f39c12;
}

.btn-outline-warning:hover {
    background: #f39c12;
    color: white;
}

.btn-info {
    background: linear-gradient(135deg, #3498db, #2980b9);
    color: white;
}

/* å“åº”å¼è®¾è®¡ */
@media (max-width: 768px) {
    .scenarios-hero {
        padding: 30px 15px;
        margin: -20px -15px 30px -15px;
    }

    .scenarios-hero h2 {
        font-size: 1.8em;
    }

    #requirements-section {
        margin: 15px;
        padding: 25px 20px;
    }

    .btn-group-custom {
        flex-direction: column;
        gap: 10px;
    }

    .btn-group-custom a {
        width: 100%;
        justify-content: center;
    }
}
</style>
{% endblock %}

{% block content %}
<!-- é¡µé¢å¤´éƒ¨ç¾åŒ– -->
<div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 40px 0; margin: -20px -20px 30px -20px; text-align: center; position: relative; overflow: hidden;">
    <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 100\"><defs><pattern id=\"dots\" width=\"20\" height=\"20\" patternUnits=\"userSpaceOnUse\"><circle cx=\"10\" cy=\"10\" r=\"1\" fill=\"white\" opacity=\"0.1\"/></pattern></defs><rect width=\"100\" height=\"100\" fill=\"url(%23dots)\"/></svg></div>
    <div style="position: relative; z-index: 1;">
        <h2 style="font-size: 2em; font-weight: 700; margin-bottom: 12px; text-shadow: 0 2px 10px rgba(0,0,0,0.3);">ğŸ“‹ {{ todo_board.title }}</h2>
        <p style="opacity: 0.9; font-size: 1em;">é¡¹ç›®ID: <code style="background: rgba(255,255,255,0.2); padding: 4px 10px; border-radius: 6px; font-family: 'Consolas', monospace; font-size: 0.9em;">{{ todo_board.task_id }}</code></p>
    </div>
</div>

    <!-- Requirements Confirmation Section -->
    {% set requirements_stage = todo_board.stages | selectattr('id', 'equalto', 'requirements_confirmation') | first %}
    {% if requirements_stage and requirements_stage.status == 'pending' %}
    <div id="requirements-section" style="max-width: 900px; margin: 15px auto; background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%); border-radius: 16px; padding: 30px; box-shadow: 0 10px 30px rgba(0,0,0,0.08); border: 1px solid rgba(102, 126, 234, 0.15);">
        <div style="text-align: center; margin-bottom: 25px;">
            <div style="display: inline-block; background: linear-gradient(135deg, #667eea, #764ba2); color: white; padding: 12px 20px; border-radius: 40px; margin-bottom: 15px; box-shadow: 0 6px 20px rgba(102, 126, 234, 0.25);">
                <h3 style="margin: 0; font-weight: 600; font-size: 1.1em;">ğŸ“ éœ€æ±‚ç¡®è®¤</h3>
            </div>
            <p style="color: #7f8c8d; margin-bottom: 0; font-size: 1em; line-height: 1.5;">è¯·ç¡®è®¤ä»¥ä¸‹ä¿¡æ¯ï¼ŒAIå°†æ ¹æ®æ‚¨çš„ç¡®è®¤ç”Ÿæˆå®šåˆ¶åŒ–çš„PPTå†…å®¹</p>
        </div>

        <!-- Loading indicator for requirements form -->
        <div id="ai-loading" class="loading-container" style="display: block;">
            <div class="loading-icon">
                <i class="fas fa-cog"></i>
            </div>
            <div class="loading-title">æ­£åœ¨å‡†å¤‡éœ€æ±‚è¡¨å•</div>
            <div class="progress-container">
                <div class="progress-bar" style="animation-duration: 2s;"></div>
            </div>
            <div class="loading-tips">
                <h5><i class="fas fa-info-circle"></i> æç¤º</h5>
                <p>è¯·ç¨å€™ï¼Œç³»ç»Ÿæ­£åœ¨ä¸ºæ‚¨å‡†å¤‡é¡¹ç›®éœ€æ±‚ç¡®è®¤è¡¨å•...</p>
            </div>
        </div>

        <form id="requirements-form" style="text-align: left; display: none;" enctype="multipart/form-data">

            <!-- Content Source Selection -->
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; color: #2c3e50; font-weight: bold;">å†…å®¹æ¥æºé€‰æ‹©</label>
                <div style="display: flex; gap: 15px; margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="radio" name="content_source" value="manual" checked onchange="toggleContentSourceTodo()" style="margin-right: 8px;">
                        <span>æ‰‹åŠ¨è¾“å…¥ä¸»é¢˜</span>
                    </label>
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="radio" name="content_source" value="file" onchange="toggleContentSourceTodo()" style="margin-right: 8px;">
                        <span>ä»æ–‡ä»¶ç”Ÿæˆ</span>
                    </label>
                </div>
            </div>

            <!-- File Upload Section (hidden by default) -->
            <div id="file-upload-section-todo" style="display: none; margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e9ecef;">
                <label style="display: block; margin-bottom: 8px; color: #2c3e50; font-weight: bold;">ğŸ“ ä¸Šä¼ æ–‡ä»¶</label>
                <input type="file" id="file_upload_todo" name="file_upload" accept=".pdf,.docx,.txt,.md,.jpg,.jpeg,.png,.xlsx,.csv"
                       style="width: 100%; padding: 8px; border: 2px dashed #3498db; background: #f8f9fa; border-radius: 6px;">
                <small style="color: #7f8c8d; display: block; margin-top: 5px;">æ”¯æŒ PDFã€DOCXã€TXTã€MD ç­‰æ ¼å¼ï¼Œæœ€å¤§ 100MB</small>

                <!-- File Processing Options -->
                <div id="file-processing-options-todo" style="margin-top: 15px; padding: 15px; background: white; border-radius: 8px; border: 1px solid #e9ecef; display: none;">
                    <h6 style="margin-bottom: 10px; color: #2c3e50;">æ–‡ä»¶å¤„ç†é€‰é¡¹</h6>

                    <div style="display: flex; flex-wrap: wrap; gap: 15px;">
                        <!-- PDFä¸“ç”¨å¤„ç†æ–¹å¼é€‰é¡¹ -->
                        <div id="pdf-processing-mode-todo" style="display: none; flex: 1; min-width: 200px;">
                            <label style="display: block; margin-bottom: 5px; color: #2c3e50; font-weight: normal;">å¤„ç†æ–¹å¼ï¼š</label>
                            <select name="file_processing_mode" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                                <option value="markitdown">æ ‡å‡†å¤„ç† (MarkItDown)</option>
                                <option value="magic_pdf">é«˜è´¨é‡å¤„ç† (Mineru)</option>
                            </select>
                        </div>

                        <!-- é€šç”¨è§£ææ·±åº¦é€‰é¡¹ -->
                        <div style="flex: 1; min-width: 200px;">
                            <label style="display: block; margin-bottom: 5px; color: #2c3e50; font-weight: normal;">è§£ææ·±åº¦ï¼š</label>
                            <select name="content_analysis_depth" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                                <option value="fast" selected>å¿«é€Ÿè§£æ</option>
                                <option value="standard">æ ‡å‡†è§£æ</option>
                                <option value="deep">æ·±åº¦è§£æ</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                <div>
                    <label style="display: block; margin-bottom: 8px; color: #2c3e50; font-weight: bold;">ä¸»é¢˜ (Topic)</label>
                    <input type="text" id="topic" name="topic" value="{{ todo_board.title.split(' - ')[0] if ' - ' in todo_board.title else todo_board.title }}"
                           style="width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px;" required>
                    <small style="color: #7f8c8d; font-size: 12px; margin-top: 5px; display: block;">æ–‡ä»¶ä¸Šä¼ æ—¶å¯ç•™ç©ºï¼Œå°†è‡ªåŠ¨ä»æ–‡ä»¶æå–æ ‡é¢˜</small>
                </div>
                <div>
                    <label style="display: block; margin-bottom: 8px; color: #2c3e50; font-weight: bold;">ç›®æ ‡å—ä¼— (Target Audience)</label>
                    <div style="margin-bottom: 10px;">
                        <select id="audience_type" name="audience_type" style="width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px;" onchange="toggleCustomAudience()" required>
                            <option value="">è¯·é€‰æ‹©ç›®æ ‡å—ä¼—</option>
                            <option value="ä¼ä¸šç®¡ç†å±‚">ä¼ä¸šç®¡ç†å±‚</option>
                            <option value="æŠ€æœ¯å›¢é˜Ÿ">æŠ€æœ¯å›¢é˜Ÿ</option>
                            <option value="é”€å”®å›¢é˜Ÿ">é”€å”®å›¢é˜Ÿ</option>
                            <option value="å­¦ç”Ÿç¾¤ä½“">å­¦ç”Ÿç¾¤ä½“</option>
                            <option value="å­¦æœ¯ç ”ç©¶è€…">å­¦æœ¯ç ”ç©¶è€…</option>
                            <option value="æŠ•èµ„äºº">æŠ•èµ„äºº</option>
                            <option value="å®¢æˆ·ç¾¤ä½“">å®¢æˆ·ç¾¤ä½“</option>
                            <option value="åŸ¹è®­å­¦å‘˜">åŸ¹è®­å­¦å‘˜</option>
                            <option value="é¡¹ç›®å›¢é˜Ÿ">é¡¹ç›®å›¢é˜Ÿ</option>
                            <option value="è¡Œä¸šä¸“å®¶">è¡Œä¸šä¸“å®¶</option>
                            <option value="æ™®é€šå¤§ä¼—">æ™®é€šå¤§ä¼—</option>
                            <option value="è‡ªå®šä¹‰">è‡ªå®šä¹‰å—ä¼—</option>
                        </select>
                    </div>
                    <!-- è‡ªå®šä¹‰å—ä¼—è¾“å…¥æ¡† -->
                    <div id="custom-audience-section" style="display: none;">
                        <input type="text" id="custom_audience" name="custom_audience"
                               placeholder="è¯·æè¿°æ‚¨çš„ç›®æ ‡å—ä¼—ï¼Œä¾‹å¦‚ï¼šåˆçº§ç¨‹åºå‘˜ã€äº§å“ç»ç†ã€é«˜ä¸­ç”Ÿç­‰..."
                               style="width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px;">
                        <small style="color: #7f8c8d; font-size: 12px; margin-top: 5px; display: block;">è¯¦ç»†æè¿°æ‚¨çš„ç›®æ ‡å—ä¼—ç‰¹å¾ï¼ŒAIå°†æ®æ­¤è°ƒæ•´å†…å®¹æ·±åº¦å’Œè¡¨è¾¾æ–¹å¼</small>
                    </div>
                </div>
            </div>





            <div style="margin-bottom: 25px;">
                <label style="display: block; margin-bottom: 8px; color: #2c3e50; font-weight: bold;">PPTé¡µæ•°è®¾ç½® (Page Count)</label>
                <p style="font-size: 12px; color: #7f8c8d; margin-bottom: 15px;">é€‰æ‹©PPTçš„é¡µæ•°ç”Ÿæˆæ–¹å¼ï¼š</p>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                    <div class="page-count-option active" data-mode="ai_decide" style="border: 2px solid #3498db; border-radius: 10px; padding: 15px; cursor: pointer; text-align: center; transition: all 0.3s ease;">
                        <div style="font-size: 24px; margin-bottom: 8px;">ğŸ¤–</div>
                        <h5 style="color: #2c3e50; margin-bottom: 5px;">AIæ™ºèƒ½å†³å®š</h5>
                        <p style="font-size: 12px; color: #7f8c8d;">AIæ ¹æ®å†…å®¹æ·±åº¦å’Œé€»è¾‘ç»“æ„è‡ªä¸»å†³å®šæœ€åˆé€‚çš„é¡µæ•°</p>
                    </div>
                    <div class="page-count-option" data-mode="custom_range" style="border: 2px solid #ddd; border-radius: 10px; padding: 15px; cursor: pointer; text-align: center; transition: all 0.3s ease;">
                        <div style="font-size: 24px; margin-bottom: 8px;">ğŸ“Š</div>
                        <h5 style="color: #2c3e50; margin-bottom: 5px;">è‡ªå®šä¹‰èŒƒå›´</h5>
                        <p style="font-size: 12px; color: #7f8c8d;">åœ¨æŒ‡å®šèŒƒå›´å†…ç”ŸæˆPPTé¡µæ•°</p>
                    </div>
                </div>
                <input type="hidden" id="page_count_mode" name="page_count_mode" value="ai_decide">

                <!-- Custom range section (hidden by default) -->
                <div id="custom-range-section" style="display: none; margin-top: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e9ecef;">
                    <div style="display: flex; gap: 15px; align-items: center;">
                        <div style="flex: 1;">
                            <label style="display: block; margin-bottom: 5px; color: #2c3e50; font-weight: bold;">æœ€å°‘é¡µæ•°</label>
                            <input type="number" id="min_pages" name="min_pages" value="8" min="5" max="50"
                                   style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 6px;">
                        </div>
                        <div style="flex: 1;">
                            <label style="display: block; margin-bottom: 5px; color: #2c3e50; font-weight: bold;">æœ€å¤šé¡µæ•°</label>
                            <input type="number" id="max_pages" name="max_pages" value="15" min="5" max="50"
                                   style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 6px;">
                        </div>
                    </div>
                    <p style="font-size: 12px; color: #7f8c8d; margin-top: 10px; margin-bottom: 0;">
                        å»ºè®®èŒƒå›´ï¼š5-50é¡µï¼ŒAIä¼šåœ¨æ­¤èŒƒå›´å†…ç”Ÿæˆæœ€åˆé€‚çš„é¡µæ•°
                    </p>
                </div>
            </div>

            <div style="margin-bottom: 25px;">
                <label style="display: block; margin-bottom: 8px; color: #2c3e50; font-weight: bold;">PPTé£æ ¼ (Style)</label>
                <p style="font-size: 12px; color: #7f8c8d; margin-bottom: 15px;">é€‰æ‹©é€‚åˆæ‚¨å†…å®¹çš„PPTé£æ ¼ï¼š</p>
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                    <div class="style-option" data-style="general" style="border: 2px solid #ddd; border-radius: 10px; padding: 15px; cursor: pointer; text-align: center; transition: all 0.3s ease;">
                        <div style="font-size: 24px; margin-bottom: 8px;">ğŸ“‹</div>
                        <h5 style="color: #2c3e50; margin-bottom: 5px;">é€šç”¨åœºæ™¯</h5>
                        <p style="font-size: 12px; color: #7f8c8d;">é€‚ç”¨äºå•†åŠ¡æ±‡æŠ¥ã€å­¦æœ¯æ¼”è®²ç­‰é€šç”¨åœºæ™¯</p>
                    </div>
                    <div class="style-option" data-style="keynote" style="border: 2px solid #ddd; border-radius: 10px; padding: 15px; cursor: pointer; text-align: center; transition: all 0.3s ease;">
                        <div style="font-size: 24px; margin-bottom: 8px;">ğŸ¯</div>
                        <h5 style="color: #2c3e50; margin-bottom: 5px;">å‘å¸ƒä¼š</h5>
                        <p style="font-size: 12px; color: #7f8c8d;">Appleé£æ ¼å‘å¸ƒä¼šï¼Œå¡ç‰‡å¼å¸ƒå±€ï¼Œç§‘æŠ€æ„Ÿå¼º</p>
                    </div>
                    <div class="style-option" data-style="custom" style="border: 2px solid #ddd; border-radius: 10px; padding: 15px; cursor: pointer; text-align: center; transition: all 0.3s ease;">
                        <div style="font-size: 24px; margin-bottom: 8px;">ğŸ¨</div>
                        <h5 style="color: #2c3e50; margin-bottom: 5px;">è‡ªå®šä¹‰é£æ ¼</h5>
                        <p style="font-size: 12px; color: #7f8c8d;">ä½¿ç”¨è‡ªå®šä¹‰æç¤ºè¯å®šåˆ¶ç‹¬ç‰¹é£æ ¼</p>
                    </div>
                </div>
                <input type="hidden" id="ppt_style" name="ppt_style" value="general" required>

                <!-- Custom style prompt input (hidden by default) -->
                <div id="custom-style-section" style="display: none; margin-top: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e9ecef;">
                    <label style="display: block; margin-bottom: 8px; color: #2c3e50; font-weight: bold;">è‡ªå®šä¹‰é£æ ¼æç¤ºè¯</label>
                    <textarea id="custom_style_prompt" name="custom_style_prompt"
                              style="width: 100%; height: 120px; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px; resize: vertical;"
                              placeholder="è¯·è¾“å…¥æ‚¨å¸Œæœ›çš„PPTé£æ ¼æè¿°ï¼Œä¾‹å¦‚ï¼šç®€çº¦ç°ä»£é£æ ¼ï¼Œä½¿ç”¨è“è‰²ä¸»é¢˜ï¼Œå¡ç‰‡å¼å¸ƒå±€..."></textarea>
                    <p style="font-size: 12px; color: #7f8c8d; margin-top: 5px;">è¯¦ç»†æè¿°æ‚¨æœŸæœ›çš„PPTé£æ ¼ï¼ŒAIå°†æ ¹æ®æ‚¨çš„æè¿°ç”Ÿæˆç›¸åº”çš„è®¾è®¡</p>
                </div>
            </div>

            <div style="text-align: center;">
                <button type="submit" id="confirm-requirements-btn"
                        style="background: #27ae60; color: white; border: none; padding: 15px 30px; border-radius: 8px; font-size: 16px; cursor: pointer; font-weight: bold;">
                    ğŸš€ ç¡®è®¤éœ€æ±‚å¹¶è·³è½¬åˆ°å¤§çº²ç”Ÿæˆ
                </button>
            </div>
        </form>
    </div>
    {% endif %}

<!-- Project Actions -->
<div style="text-align: center; margin-bottom: 40px;">
    <div style="display: inline-flex; gap: 12px; flex-wrap: wrap; justify-content: center; background: white; padding: 20px; border-radius: 16px; box-shadow: 0 8px 25px rgba(0,0,0,0.08);">
        <a href="/projects/{{ todo_board.task_id }}" style="background: linear-gradient(135deg, #3498db, #2980b9); color: white; text-decoration: none; padding: 10px 20px; border-radius: 10px; font-weight: 600; transition: all 0.3s ease; box-shadow: 0 3px 12px rgba(52, 152, 219, 0.25); display: flex; align-items: center; gap: 6px; font-size: 0.9em;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 5px 16px rgba(52, 152, 219, 0.35)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 3px 12px rgba(52, 152, 219, 0.25)'">
            ğŸ“Š é¡¹ç›®è¯¦æƒ…
        </a>

        {% if todo_board.overall_progress >= 100 %}
        <a href="/projects/{{ todo_board.task_id }}/preview" target="_blank" style="background: linear-gradient(135deg, #27ae60, #229954); color: white; text-decoration: none; padding: 10px 20px; border-radius: 10px; font-weight: 600; transition: all 0.3s ease; box-shadow: 0 3px 12px rgba(39, 174, 96, 0.25); display: flex; align-items: center; gap: 6px; font-size: 0.9em;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 5px 16px rgba(39, 174, 96, 0.35)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 3px 12px rgba(39, 174, 96, 0.25)'">
            ğŸ” é¢„è§ˆ PPT
        </a>
        <a href="/projects/{{ todo_board.task_id }}/edit" target="_blank" style="background: linear-gradient(135deg, #e74c3c, #c0392b); color: white; text-decoration: none; padding: 10px 20px; border-radius: 10px; font-weight: 600; transition: all 0.3s ease; box-shadow: 0 3px 12px rgba(231, 76, 60, 0.25); display: flex; align-items: center; gap: 6px; font-size: 0.9em;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 5px 16px rgba(231, 76, 60, 0.35)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 3px 12px rgba(231, 76, 60, 0.25)'">
            âœï¸ ç¼–è¾‘ PPT
        </a>
        {% endif %}

        <a href="/projects" style="background: linear-gradient(135deg, #95a5a6, #7f8c8d); color: white; text-decoration: none; padding: 10px 20px; border-radius: 10px; font-weight: 600; transition: all 0.3s ease; box-shadow: 0 3px 12px rgba(149, 165, 166, 0.25); display: flex; align-items: center; gap: 6px; font-size: 0.9em;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 5px 16px rgba(149, 165, 166, 0.35)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 3px 12px rgba(149, 165, 166, 0.25)'">
            ğŸ“‹ è¿”å›é¡¹ç›®åˆ—è¡¨
        </a>
    </div>
</div>

<!-- Task execution is now handled directly in the stage cards -->

<style>
@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

@keyframes blink {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0; }
}

.todo-stage {
    transition: all 0.3s ease;
}

.todo-stage:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 20px rgba(0,0,0,0.15);
}

.btn {
    transition: all 0.3s ease;
}

.btn:hover {
    transform: translateY(-1px);
}

.btn-stream:hover {
    background: #2980b9 !important;
    transform: scale(1.05);
}

.task-item {
    transition: all 0.3s ease;
}

.task-item.active {
    background: #e8f4fd !important;
    border-left: 4px solid #3498db;
}

.output-cursor {
    display: inline-block;
}

.output-cursor.hidden {
    display: none;
}

.style-option {
    transition: all 0.3s ease;
}

.style-option:hover {
    border-color: #3498db !important;
    transform: translateY(-2px);
    box-shadow: 0 4px 15px rgba(52, 152, 219, 0.2);
}

.style-option.selected {
    border-color: #3498db !important;
    background: #e8f4fd !important;
    transform: translateY(-1px);
    box-shadow: 0 2px 10px rgba(52, 152, 219, 0.3);
}

.page-count-option {
    transition: all 0.3s ease;
}

.page-count-option:hover {
    border-color: #3498db !important;
    transform: translateY(-2px);
    box-shadow: 0 4px 15px rgba(52, 152, 219, 0.2);
}

.page-count-option.active {
    border-color: #3498db !important;
    background: #e8f4fd !important;
    transform: translateY(-1px);
    box-shadow: 0 2px 10px rgba(52, 152, 219, 0.3);
}
</style>
{% endblock %}

{% block extra_js %}
<script>
let currentProjectId = '{{ todo_board.task_id }}';
let outlineGenerationStarted = false; // é˜²æ­¢é‡å¤è°ƒç”¨å¤§çº²ç”Ÿæˆ

// Page count selection functionality
function initializePageCountSelection() {
    const pageCountOptions = document.querySelectorAll('.page-count-option');
    const pageCountModeInput = document.getElementById('page_count_mode');
    const customRangeSection = document.getElementById('custom-range-section');

    pageCountOptions.forEach(option => {
        option.addEventListener('click', function() {
            // Remove active class from all options
            pageCountOptions.forEach(opt => opt.classList.remove('active'));

            // Add active class to clicked option
            this.classList.add('active');

            // Update hidden input value
            const selectedMode = this.getAttribute('data-mode');
            pageCountModeInput.value = selectedMode;

            // Show/hide custom range section
            if (selectedMode === 'custom_range') {
                customRangeSection.style.display = 'block';
            } else {
                customRangeSection.style.display = 'none';
            }

            // Update visual styles
            updatePageCountStyles();
        });
    });

    // Set default selection
    const defaultOption = document.querySelector('.page-count-option[data-mode="ai_decide"]');
    if (defaultOption) {
        defaultOption.classList.add('active');
    }

    // Initialize visual styles
    updatePageCountStyles();
}

// Update page count option visual styles
function updatePageCountStyles() {
    const pageCountOptions = document.querySelectorAll('.page-count-option');
    pageCountOptions.forEach(option => {
        if (option.classList.contains('active')) {
            option.style.borderColor = '#3498db';
            option.style.background = '#e8f4fd';
        } else {
            option.style.borderColor = '#ddd';
            option.style.background = 'white';
        }
    });
}

// Style selection functionality
function initializeStyleSelection() {
    const styleOptions = document.querySelectorAll('.style-option');
    const pptStyleInput = document.getElementById('ppt_style');
    const customStyleSection = document.getElementById('custom-style-section');

    styleOptions.forEach(option => {
        option.addEventListener('click', function() {
            // Remove selected class from all options
            styleOptions.forEach(opt => opt.classList.remove('selected'));

            // Add selected class to clicked option
            this.classList.add('selected');

            // Update hidden input value
            const selectedStyle = this.getAttribute('data-style');
            pptStyleInput.value = selectedStyle;

            // Show/hide custom style section
            if (selectedStyle === 'custom') {
                customStyleSection.style.display = 'block';
            } else {
                customStyleSection.style.display = 'none';
            }
        });
    });

    // Set default selection
    const defaultOption = document.querySelector('.style-option[data-style="general"]');
    if (defaultOption) {
        defaultOption.classList.add('selected');
    }
}

// Initialize outline display for completed stages
function initializeOutlineDisplay() {
    // Check if outline generation stage is completed and has content
    const outlineStage = document.querySelector('[data-stage-id="outline_generation"]');
    if (outlineStage) {
        const statusIcon = outlineStage.querySelector('.stage-status-icon');
        if (statusIcon && statusIcon.textContent === 'âœ“') {
            // Stage is completed, ensure output area is visible
            const outputDiv = document.getElementById('outline-output-outline_generation');
            if (outputDiv) {
                outputDiv.style.display = 'block';

                // Hide cursor for completed stage
                const cursorDiv = document.getElementById('outline-cursor-outline_generation');
                if (cursorDiv) {
                    cursorDiv.style.display = 'none';
                }
            }
        }
    }
}

// AIå¤§è„‘æ€è€ƒåŠ¨ç”»æ§åˆ¶å‡½æ•°
let brainAnimationInterval = null;
let activeBrains = new Set();

function startBrainAnimation(prefix = '') {
    const brainId = prefix ? `loading-brain-${prefix}` : 'loading-brain';
    const brain = document.getElementById(brainId);

    if (!brain) return;

    // æ·»åŠ åˆ°æ´»åŠ¨å¤§è„‘é›†åˆ
    activeBrains.add(prefix);

    // å¯åŠ¨å¤§è„‘æ€è€ƒçŠ¶æ€
    brain.classList.remove('completed');

    // åˆ›å»ºåŠ¨æ€æ–‡å­—æ•ˆæœ
    function updateThinkingText() {
        if (!activeBrains.has(prefix)) return;

        const textElement = brain.querySelector('.generating-text');
        if (textElement) {
            const texts = [
                'æ­£åœ¨åˆ†æå†…å®¹ç»“æ„',
                'æ­£åœ¨æ„å»ºé€»è¾‘æ¡†æ¶',
                'æ­£åœ¨ä¼˜åŒ–å¤§çº²å±‚æ¬¡',
                'æ­£åœ¨å®Œå–„å†…å®¹è¦ç‚¹',
                'æ­£åœ¨ç”ŸæˆPPTå¤§çº²'
            ];

            const randomText = texts[Math.floor(Math.random() * texts.length)];
            textElement.textContent = randomText;
        }
    }

    // æ¯3ç§’æ›´æ–°æ€è€ƒæ–‡å­—
    updateThinkingText();
    const textInterval = setInterval(updateThinkingText, 3000);

    // å­˜å‚¨å®šæ—¶å™¨å¼•ç”¨
    if (!brainAnimationInterval) {
        brainAnimationInterval = {};
    }
    brainAnimationInterval[prefix] = textInterval;
}

function stopBrainAnimation(prefix = '') {
    const brainId = prefix ? `loading-brain-${prefix}` : 'loading-brain';
    const brain = document.getElementById(brainId);

    // ä»æ´»åŠ¨å¤§è„‘é›†åˆä¸­ç§»é™¤
    activeBrains.delete(prefix);

    if (brain) {
        brain.classList.add('completed');

        // æ›´æ–°å®Œæˆæ–‡å­—
        const textElement = brain.querySelector('.generating-text');
        if (textElement) {
            textElement.textContent = 'å¤§çº²ç”Ÿæˆå®Œæˆ';
        }

        const dotsElement = brain.querySelector('.generating-dots');
        if (dotsElement) {
            dotsElement.textContent = 'âœ“';
        }
    }

    // æ¸…é™¤æ–‡å­—æ›´æ–°å®šæ—¶å™¨
    if (brainAnimationInterval && brainAnimationInterval[prefix]) {
        clearInterval(brainAnimationInterval[prefix]);
        delete brainAnimationInterval[prefix];
    }
}

// å…¼å®¹æ—§çš„å‡½æ•°å
function startLoadingAnimation(prefix = '') {
    startBrainAnimation(prefix);
}

function stopLoadingAnimation(prefix = '') {
    stopBrainAnimation(prefix);
}

// å…¼å®¹æ¼æ–—åŠ¨ç”»å‡½æ•°å
function startFunnelAnimation(prefix = '') {
    startBrainAnimation(prefix);
}

function stopFunnelAnimation(prefix = '') {
    stopBrainAnimation(prefix);
}

// å…¼å®¹ä¹¦æœ¬åŠ¨ç”»å‡½æ•°å
function startBookAnimation(prefix = '') {
    startBrainAnimation(prefix);
}

function stopBookAnimation(prefix = '') {
    stopBrainAnimation(prefix);
}



// æ˜¾ç¤ºæˆåŠŸå®ŒæˆåŠ¨ç”»
function showBrainCompletion(prefix = '') {
    const brainId = prefix ? `loading-brain-${prefix}` : 'loading-brain';
    const brain = document.getElementById(brainId);

    if (brain) {
        // åœæ­¢æ€è€ƒåŠ¨ç”»å¹¶æ˜¾ç¤ºå®ŒæˆçŠ¶æ€
        stopBrainAnimation(prefix);
        brain.classList.add('completed');

        // 2ç§’åéšè—æ•´ä¸ªåŠ¨ç”»å®¹å™¨
        setTimeout(() => {
            if (brain.parentNode && brain.parentNode.parentNode) {
                brain.parentNode.parentNode.style.display = 'none';
            }
        }, 2000);
    }
}

// å…¼å®¹æ—§çš„å‡½æ•°å
function showBookCompletion(prefix = '') {
    showBrainCompletion(prefix);
}

function showFunnelCompletion(prefix = '') {
    showBrainCompletion(prefix);
}

// Handle requirements form submission and AI suggestions loading
document.addEventListener('DOMContentLoaded', function() {
    // Initialize outline display if already completed
    initializeOutlineDisplay();

    // Initialize page count selection
    initializePageCountSelection();

    // Initialize style selection
    initializeStyleSelection();

    // Check if we should auto-start outline generation
    checkAutoStartOutline();

    // ç›´æ¥æ˜¾ç¤ºéœ€æ±‚è¡¨å•ï¼Œä¸å†åŠ è½½AIå»ºè®®
    showRequirementsForm();

    const requirementsForm = document.getElementById('requirements-form');
    if (requirementsForm) {
        requirementsForm.addEventListener('submit', async function(e) {
            e.preventDefault();

            const formData = new FormData(requirementsForm);
            const confirmBtn = document.getElementById('confirm-requirements-btn');

            const requirementsSection = document.getElementById('requirements-section');
            if (requirementsSection) {
                requirementsSection.style.display = 'none';
            }

            
            showOutlineSection();

            
            try {
                const response = await fetch(`/projects/${currentProjectId}/confirm-requirements`, {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (response.ok && result.status === 'success') {
                    
                    setTimeout(() => {
                        const contentSource = document.querySelector('input[name="content_source"]:checked');
                        if (contentSource && contentSource.value === 'file') {
                            
                            startFileOutlineGeneration();
                        } else {
                            
                            startOutlineGenerationNew();
                        }
                    }, 1000); 
                } else {
                    console.error('Requirements confirmation failed:', result.message);
                    
                    alert('éœ€æ±‚ç¡®è®¤å¤±è´¥: ' + (result.message || 'æœªçŸ¥é”™è¯¯'));
                    
                    const requirementsSection = document.getElementById('requirements-section');
                    const outlineSection = document.getElementById('outline-section');
                    if (requirementsSection) requirementsSection.style.display = 'block';
                    if (outlineSection) outlineSection.style.display = 'none';
                }
            } catch (error) {
                console.error('Error confirming requirements:', error);
                alert('éœ€æ±‚ç¡®è®¤å¤±è´¥: ' + error.message);
                
                const requirementsSection = document.getElementById('requirements-section');
                const outlineSection = document.getElementById('outline-section');
                if (requirementsSection) requirementsSection.style.display = 'block';
                if (outlineSection) outlineSection.style.display = 'none';
            }
        });
    }
});

// Check if we should auto-start outline generation
function checkAutoStartOutline() {
    // é˜²æ­¢é‡å¤è°ƒç”¨
    if (outlineGenerationStarted) {
        console.log('Outline generation already started, skipping auto-start check...');
        return;
    }

    // Check if outline section is visible and outline generation should start
    const outlineSection = document.getElementById('outline-section');
    if (outlineSection && outlineSection.style.display !== 'none') {
        // Check if outline generation is in running state
        const outlineCursor = document.getElementById('outline-cursor');
        if (outlineCursor && outlineCursor.style.display !== 'none') {
            // Auto-start outline generation
            setTimeout(() => {
                startOutlineGenerationNew();
            }, 500);
        }
    }
}

// Show outline section
function showOutlineSection() {
    // Create and show outline section if it doesn't exist
    let outlineSection = document.getElementById('outline-section');
    if (!outlineSection) {
        outlineSection = document.createElement('div');
        outlineSection.id = 'outline-section';
        outlineSection.style.cssText = 'max-width: 1200px; margin: 20px auto; background: white; border-radius: 15px; padding: 30px; box-shadow: 0 4px 20px rgba(0,0,0,0.1);';

        outlineSection.innerHTML = `
            <div style="text-align: center; margin-bottom: 30px;">
                <h3 style="color: #2c3e50; margin-bottom: 10px;">
                    <i class="fas fa-brain"></i> PPT å¤§çº²ç”Ÿæˆ
                </h3>
                <p style="color: #7f8c8d;">AIæ­£åœ¨ä¸ºæ‚¨ç”Ÿæˆä¸“ä¸šçš„PPTå¤§çº²ï¼Œæ‚¨å¯ä»¥å®æ—¶æŸ¥çœ‹å¹¶ç¼–è¾‘</p>
            </div>

            <div style="background: #f8f9fa; border-radius: 10px; padding: 20px; border: 2px solid #e9ecef;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h5 style="color: #2c3e50; margin: 0;">
                        <i class="fas fa-list-alt"></i> å¤§çº²å†…å®¹
                        <span id="outline-status" style="color: #f39c12; font-size: 0.8em; margin-left: 10px; display: none;">
                        </span>
                    </h5>

                    <div style="display: flex; align-items: center; gap: 10px;">
                        <!-- View Toggle Buttons - Always show -->
                        <div style="display: flex; background: #e9ecef; border-radius: 5px; padding: 2px;">
                            <button id="json-view-btn-new" onclick="switchOutlineViewNew('json')"
                                    style="background: #3498db; color: white; border: none; padding: 5px 10px; border-radius: 3px; font-size: 11px; cursor: pointer; transition: all 0.3s ease;">
                                <i class="fas fa-code"></i> JSON
                            </button>
                            <button id="outline-view-btn-new" onclick="switchOutlineViewNew('outline')"
                                    style="background: transparent; color: #6c757d; border: none; padding: 5px 10px; border-radius: 3px; font-size: 11px; cursor: pointer; transition: all 0.3s ease;">
                                <i class="fas fa-list-ul"></i> å¤§çº²è§†å›¾
                            </button>
                        </div>

                        <!-- Action Buttons -->
                        <div id="outline-actions" style="display: none;">
                            <button onclick="regenerateOutlineNew()" class="btn btn-sm btn-outline-warning" style="margin-right: 8px;">
                                <i class="fas fa-sync"></i> é‡æ–°ç”Ÿæˆå¤§çº²
                            </button>
                            <button onclick="editOutlineNew()" class="btn btn-sm btn-outline-primary" style="margin-right: 8px;">
                                <i class="fas fa-edit"></i> ç¼–è¾‘å¤§çº²
                            </button>
                        </div>
                    </div>
                </div>

                <!-- JSON View (default) -->
                <div id="outline-content-display" style="background: white; border: 1px solid #dee2e6; border-radius: 8px; padding: 25px; min-height: 400px; max-height: 600px; overflow-y: auto; font-family: 'Microsoft YaHei', Arial, sans-serif; line-height: 1.8; font-size: 14px; display: block; position: relative;">
                    <div id="outline-placeholder" class="loading-container">
                        <div class="loading-icon">
                            <i class="fas fa-brain"></i>
                        </div>
                        <div class="loading-title">AIæ­£åœ¨ç”ŸæˆPPTå¤§çº²</div>

                        <div class="brain-container">
                            <div class="ai-brain" id="loading-brain-dynamic">
                                <div class="brain-core">
                                    <div class="brain-icon">ğŸ§ </div>
                                </div>
                                <svg class="progress-ring" width="140" height="140">
                                    <circle class="progress-ring-circle" cx="70" cy="70" r="70"></circle>
                                    <circle class="progress-ring-progress" cx="70" cy="70" r="70"></circle>
                                </svg>
                                <div class="neural-network">
                                    <div class="neural-line" style="--rotation: 45deg;"></div>
                                    <div class="neural-line" style="--rotation: -30deg;"></div>
                                    <div class="neural-line" style="--rotation: -45deg;"></div>
                                    <div class="neural-line" style="--rotation: 60deg;"></div>
                                </div>
                                <div class="thought-bubbles">
                                    <div class="thought-bubble"></div>
                                    <div class="thought-bubble"></div>
                                    <div class="thought-bubble"></div>
                                </div>
                                <div class="text-generation">
                                    <div class="generating-text">æ­£åœ¨åˆ†æå†…å®¹ç»“æ„</div>
                                    <div class="generating-dots">â€¢ â€¢ â€¢</div>
                                </div>
                            </div>
                        </div>

                        <div class="loading-tips">
                            <h5><i class="fas fa-lightbulb"></i> å°è´´å£«</h5>
                            <p>AIæ­£åœ¨æ ¹æ®æ‚¨çš„éœ€æ±‚æ™ºèƒ½ç”ŸæˆPPTå¤§çº²ï¼ŒåŒ…æ‹¬æ ‡é¢˜ã€å†…å®¹è¦ç‚¹å’Œé€»è¾‘ç»“æ„ã€‚ç”Ÿæˆå®Œæˆåæ‚¨å¯ä»¥å®æ—¶ç¼–è¾‘å’Œè°ƒæ•´ã€‚</p>
                        </div>
                    </div>

                    <!-- å…‰æ ‡å…ƒç´ ç§»åˆ°å†…å®¹å®¹å™¨å†…éƒ¨ï¼Œä½¿ç”¨ç»å¯¹å®šä½ï¼Œé»˜è®¤éšè— -->
                    <div id="outline-cursor" style="position: absolute; bottom: 20px; right: 20px; display: none; width: 2px; height: 16px; background: #3498db; animation: blink 1s infinite; pointer-events: none;"></div>
                </div>

                <!-- Outline View -->
                <div id="outline-view-new" style="display: none;">
                    <!-- Outline Toolbar -->
                    <div id="outline-toolbar-new" style="background: #f8f9fa; border: 1px solid #dee2e6; border-bottom: none; border-radius: 8px 8px 0 0; padding: 10px; display: flex; align-items: center; justify-content: space-between;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="color: #2c3e50; font-weight: 500;">
                                <i class="fas fa-list-ul"></i> PPTå¤§çº²é¢„è§ˆ
                            </span>
                            <span style="color: #7f8c8d; font-size: 12px;">æ”¯æŒç®€æ´è§†å›¾å’Œè¯¦ç»†è§†å›¾åˆ‡æ¢</span>
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <button onclick="toggleOutlineViewModeNew()" class="btn btn-xs btn-info" title="åˆ‡æ¢è§†å›¾æ¨¡å¼">
                                <i class="fas fa-eye"></i> <span id="viewToggleTextNew">è¯¦ç»†è§†å›¾</span>
                            </button>
                            <button onclick="editOutlineNew()" class="btn btn-xs btn-primary" title="ä¿®æ”¹å¤§çº²">
                                <i class="fas fa-edit"></i> ä¿®æ”¹å¤§çº²
                            </button>
                            <button onclick="exportOutlineJSONNew()" class="btn btn-xs btn-success" title="å¯¼å‡ºJSON">
                                <i class="fas fa-download"></i> å¯¼å‡ºJSON
                            </button>
                        </div>
                    </div>

                    <div id="outline-container-new" style="background: white; border: 1px solid #dee2e6; border-radius: 0 0 8px 8px; height: 500px; overflow-y: auto; position: relative;">
                        <div id="outline-content-new" style="width: 100%; height: 100%; padding: 20px;">
                            <!-- å¤§çº²å†…å®¹å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
                        </div>
                        <div id="outline-loading-new" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #7f8c8d; display: none;">
                            <i class="fas fa-spinner fa-spin fa-2x" style="margin-bottom: 15px;"></i>
                            <p>æ­£åœ¨åŠ è½½å¤§çº²...</p>
                        </div>
                        <div id="outline-error-new" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #e74c3c; display: none;">
                            <i class="fas fa-exclamation-triangle fa-2x" style="margin-bottom: 15px;"></i>
                            <p>å¤§çº²åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ•°æ®æ ¼å¼</p>
                        </div>
                        <div id="outline-empty-new" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #7f8c8d; display: block;">
                            <i class="fas fa-list-ul fa-3x" style="margin-bottom: 20px; opacity: 0.3;"></i>
                            <h4 style="color: #95a5a6; margin-bottom: 15px;">å¤§çº²è§†å›¾</h4>
                            <p style="margin-bottom: 20px;">å¤§çº²ç”Ÿæˆå®Œæˆåï¼Œç»“æ„åŒ–å†…å®¹å°†åœ¨è¿™é‡Œæ˜¾ç¤º</p>
                            <p style="font-size: 14px; color: #bdc3c7;">æ”¯æŒç®€æ´è§†å›¾å’Œè¯¦ç»†è§†å›¾åˆ‡æ¢ï¼Œå¯ç¼–è¾‘å¤§çº²å†…å®¹</p>
                        </div>
                    </div>
                </div>



                <div id="outline-edit-area" style="display: none; margin-top: 20px;">
                    <h6 style="color: #2c3e50; margin-bottom: 15px;">
                        <i class="fas fa-code"></i> ç¼–è¾‘å¤§çº²JSON
                    </h6>
                    <div style="background: #f8f9fa; padding: 10px; border-radius: 5px; margin-bottom: 10px; font-size: 12px; color: #6c757d;">
                        <i class="fas fa-info-circle"></i>
                        è¯·ç¼–è¾‘JSONæ ¼å¼çš„å¤§çº²ã€‚ç¡®ä¿JSONæ ¼å¼æ­£ç¡®ï¼ŒåŒ…å«titleå’Œslidesæ•°ç»„ã€‚
                    </div>
                    <textarea id="outline-editor"
                              style="width: 100%; height: 400px; padding: 15px; border: 1px solid #ddd; border-radius: 8px;
                                     font-family: 'Consolas', 'Monaco', 'Courier New', monospace; font-size: 13px; line-height: 1.4;
                                     resize: vertical; background: #f8f9fa;"
                              placeholder='è¯·è¾“å…¥JSONæ ¼å¼çš„å¤§çº²ï¼Œä¾‹å¦‚ï¼š
{
  "title": "PPTæ ‡é¢˜",
  "slides": [
    {
      "page_number": 1,
      "title": "é¡µé¢æ ‡é¢˜",
      "content_points": ["è¦ç‚¹1", "è¦ç‚¹2"],
      "slide_type": "title"
    }
  ]
}'></textarea>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 15px;">
                        <div style="font-size: 12px; color: #6c757d;">
                            <i class="fas fa-lightbulb"></i>
                            æç¤ºï¼šslide_typeå¯é€‰å€¼ï¼štitle, content, agenda, thankyou
                        </div>
                        <div>
                            <button onclick="validateJSON()" class="btn btn-sm btn-info" style="margin-right: 8px;">
                                <i class="fas fa-check-circle"></i> éªŒè¯JSON
                            </button>
                            <button onclick="cancelEditOutlineNew()" class="btn btn-sm btn-secondary" style="margin-right: 8px;">
                                <i class="fas fa-times"></i> å–æ¶ˆ
                            </button>
                            <button onclick="saveOutlineEditNew()" class="btn btn-sm btn-primary">
                                <i class="fas fa-save"></i> ä¿å­˜ä¿®æ”¹
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        `;

        // Insert after requirements section or at the beginning
        const requirementsSection = document.getElementById('requirements-section');
        if (requirementsSection) {
            requirementsSection.parentNode.insertBefore(outlineSection, requirementsSection.nextSibling);
        } else {
            const container = document.querySelector('div[style*="text-align: center"]');
            if (container) {
                container.appendChild(outlineSection);
            }
        }
    }

    outlineSection.style.display = 'block';

    // å¯åŠ¨ç­‰å¾…åŠ¨ç”»
    setTimeout(() => {
        startFunnelAnimation('dynamic');
    }, 100);
}


function showRequirementsForm() {
    try {
        // Hide loading indicator
        const loadingElement = document.getElementById('ai-loading');
        if (loadingElement) {
            loadingElement.style.display = 'none';
        }

        // Show form
        const formElement = document.getElementById('requirements-form');
        if (formElement) {
            formElement.style.display = 'block';
        }


    } catch (error) {
        console.error('Error showing requirements form:', error);

        // Hide loading and show form with default options
        const loadingElement = document.getElementById('ai-loading');
        if (loadingElement) {
            loadingElement.style.display = 'none';
        }

        const formElement = document.getElementById('requirements-form');
        if (formElement) {
            formElement.style.display = 'block';
        }
    }
}

// Populate checkbox options
function populateCheckboxOptions(containerId, options, name) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';

    options.forEach(option => {
        const div = document.createElement('div');
        div.style.cssText = 'padding: 10px; border: 1px solid #ddd; border-radius: 6px; background: white; cursor: pointer; transition: all 0.3s ease;';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.name = name;
        checkbox.value = option;
        checkbox.id = `${name}_${options.indexOf(option)}`;
        checkbox.style.marginRight = '8px';

        const label = document.createElement('label');
        label.htmlFor = checkbox.id;
        label.textContent = option;
        label.style.cursor = 'pointer';

        div.appendChild(checkbox);
        div.appendChild(label);

        // Add click handler for the entire div
        div.addEventListener('click', function(e) {
            if (e.target !== checkbox) {
                checkbox.checked = !checkbox.checked;
            }
            updateCheckboxStyle(div, checkbox.checked);
        });

        // Add change handler for checkbox
        checkbox.addEventListener('change', function() {
            updateCheckboxStyle(div, this.checked);
        });

        container.appendChild(div);
    });
}

// Populate radio options
function populateRadioOptions(containerId, options, name) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';

    options.forEach(option => {
        const div = document.createElement('div');
        div.style.cssText = 'padding: 10px 15px; border: 1px solid #ddd; border-radius: 6px; background: white; cursor: pointer; transition: all 0.3s ease;';

        const radio = document.createElement('input');
        radio.type = 'radio';
        radio.name = name;
        radio.value = option;
        radio.id = `${name}_${options.indexOf(option)}`;
        radio.style.marginRight = '8px';

        const label = document.createElement('label');
        label.htmlFor = radio.id;
        label.textContent = option;
        label.style.cursor = 'pointer';

        div.appendChild(radio);
        div.appendChild(label);

        // Add click handler for the entire div
        div.addEventListener('click', function(e) {
            if (e.target !== radio) {
                radio.checked = true;
            }
            updateRadioStyles(name);
        });

        // Add change handler for radio
        radio.addEventListener('change', function() {
            updateRadioStyles(name);
        });

        container.appendChild(div);
    });
}

// Update checkbox visual style
function updateCheckboxStyle(div, checked) {
    if (checked) {
        div.style.background = '#e8f4fd';
        div.style.borderColor = '#3498db';
        div.style.transform = 'scale(1.02)';
    } else {
        div.style.background = 'white';
        div.style.borderColor = '#ddd';
        div.style.transform = 'scale(1)';
    }
}

// Update radio button visual styles
function updateRadioStyles(name) {
    const radios = document.querySelectorAll(`input[name="${name}"]`);
    radios.forEach(radio => {
        const div = radio.parentElement;
        if (radio.checked) {
            div.style.background = '#e8f4fd';
            div.style.borderColor = '#3498db';
            div.style.transform = 'scale(1.02)';
        } else {
            div.style.background = 'white';
            div.style.borderColor = '#ddd';
            div.style.transform = 'scale(1)';
        }
    });
}


// Outline editing functions
function editOutline(stageId) {
    const outlineContent = document.getElementById(`outline-content-${stageId}`);
    const outlineEdit = document.getElementById(`outline-edit-${stageId}`);
    const outlineEditor = document.getElementById(`outline-editor-${stageId}`);

    if (outlineContent && outlineEdit && outlineEditor) {
        // Copy current content to editor
        outlineEditor.value = outlineContent.textContent;

        // Hide content, show editor
        outlineContent.parentElement.style.display = 'none';
        outlineEdit.style.display = 'block';
    }
}

function cancelEditOutline(stageId) {
    const outlineContent = document.getElementById(`outline-content-${stageId}`);
    const outlineEdit = document.getElementById(`outline-edit-${stageId}`);

    if (outlineContent && outlineEdit) {
        // Show content, hide editor
        outlineContent.parentElement.style.display = 'block';
        outlineEdit.style.display = 'none';
    }
}



// File outline generation function for file uploads (non-streaming)
async function startFileOutlineGeneration() {
    console.log('Starting file outline generation (non-streaming)');

    // é˜²æ­¢é‡å¤è°ƒç”¨
    if (outlineGenerationStarted) {
        console.log('Outline generation already started, skipping...');
        return;
    }

    const contentDiv = document.getElementById('outline-content-display');
    const cursorDiv = document.getElementById('outline-cursor');
    const statusDiv = document.getElementById('outline-status');
    const placeholderDiv = document.getElementById('outline-placeholder');

    if (!contentDiv) {
        console.error('Outline content div not found');
        return;
    }

    // æ ‡è®°ä¸ºå·²å¼€å§‹
    outlineGenerationStarted = true;

    // æ˜¾ç¤ºå¢å¼ºçš„åŠ è½½çŠ¶æ€
    if (placeholderDiv) {
        placeholderDiv.innerHTML = `
            <div class="loading-icon">
                <i class="fas fa-file-alt"></i>
            </div>
            <div class="loading-title">æ­£åœ¨ä»æ–‡ä»¶ç”ŸæˆPPTå¤§çº²</div>

            <div class="brain-container">
                <div class="ai-brain" id="loading-brain-file">
                    <div class="brain-core">
                        <div class="brain-icon">ğŸ“„</div>
                    </div>
                    <svg class="progress-ring" width="140" height="140">
                        <circle class="progress-ring-circle" cx="70" cy="70" r="70"></circle>
                        <circle class="progress-ring-progress" cx="70" cy="70" r="70"></circle>
                    </svg>
                    <div class="neural-network">
                        <div class="neural-line" style="--rotation: 45deg;"></div>
                        <div class="neural-line" style="--rotation: -30deg;"></div>
                        <div class="neural-line" style="--rotation: -45deg;"></div>
                        <div class="neural-line" style="--rotation: 60deg;"></div>
                    </div>
                    <div class="thought-bubbles">
                        <div class="thought-bubble"></div>
                        <div class="thought-bubble"></div>
                        <div class="thought-bubble"></div>
                    </div>
                    <div class="text-generation">
                        <div class="generating-text">æ­£åœ¨è§£ææ–‡ä»¶å†…å®¹</div>
                        <div class="generating-dots">â€¢ â€¢ â€¢</div>
                    </div>
                </div>
            </div>

            <div class="loading-tips">
                <h5><i class="fas fa-lightbulb"></i> å°è´´å£«</h5>
                <p>AIæ­£åœ¨æ™ºèƒ½åˆ†ææ‚¨ä¸Šä¼ çš„æ–‡ä»¶å†…å®¹ï¼Œæå–å…³é”®ä¿¡æ¯å¹¶ç”Ÿæˆç»“æ„åŒ–çš„PPTå¤§çº²ã€‚</p>
            </div>
        `;
        placeholderDiv.className = 'loading-container';
        placeholderDiv.style.display = 'block';

        // å¯åŠ¨æ–‡ä»¶å¤„ç†åŠ¨ç”»
        startBrainAnimation('file');
    }

    // éšè—å…‰æ ‡ï¼ˆæ–‡ä»¶ç”Ÿæˆä¸éœ€è¦æµå¼æ•ˆæœï¼‰
    if (cursorDiv) {
        cursorDiv.style.display = 'none';
    }

    try {
        // è°ƒç”¨æ–‡ä»¶å¤§çº²ç”Ÿæˆæ¥å£ï¼ˆéæµå¼ï¼‰
        const response = await fetch(`/projects/${currentProjectId}/generate-file-outline`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result = await response.json();

        if (result.error) {
            // åœæ­¢åŠ è½½åŠ¨ç”»
            stopBookAnimation('file');

            contentDiv.innerHTML = `<div style="color: #e74c3c; text-align: center; padding: 20px;">
                <i class="fas fa-exclamation-triangle"></i> é”™è¯¯: ${result.error}
            </div>`;
            if (placeholderDiv) placeholderDiv.style.display = 'none';

            // é‡ç½®æ ‡å¿—ï¼Œå…è®¸é‡è¯•
            outlineGenerationStarted = false;
            return;
        }

        // åœæ­¢åŠ è½½åŠ¨ç”»
        stopBookAnimation('file');

        // éšè—åŠ è½½çŠ¶æ€
        if (placeholderDiv) {
            placeholderDiv.style.display = 'none';
        }

        // ä¸€æ¬¡æ€§æ˜¾ç¤ºå®Œæ•´çš„å¤§çº²å†…å®¹
        if (result.outline_content) {
            // æ ¼å¼åŒ–JSONå†…å®¹
            let formattedContent;
            try {
                const parsed = JSON.parse(result.outline_content);
                formattedContent = JSON.stringify(parsed, null, 2);
            } catch (e) {
                formattedContent = result.outline_content;
            }

            // æ˜¾ç¤ºæ ¼å¼åŒ–çš„å†…å®¹ - ä½¿ç”¨textContentè€Œä¸æ˜¯innerHTMLæ¥é¿å…HTMLè½¬ä¹‰é—®é¢˜
            const preElement = document.createElement('pre');
            preElement.style.cssText = 'margin: 0; font-family: "Consolas", "Monaco", "Courier New", monospace; font-size: 13px; white-space: pre-wrap; word-wrap: break-word;';
            preElement.textContent = formattedContent;
            contentDiv.innerHTML = '';
            contentDiv.appendChild(preElement);
        }

        // é‡ç½®æ ‡å¿—ï¼Œå…è®¸ä¸‹æ¬¡ç”Ÿæˆ
        outlineGenerationStarted = false;

        // Show action buttons
        const actionsDiv = document.getElementById('outline-actions');
        if (actionsDiv) {
            actionsDiv.style.display = 'block';
        }

        // å°è¯•è§£æå¹¶æ¸²æŸ“å¤§çº²é¢„è§ˆ
        try {
            const parsedOutline = JSON.parse(result.outline_content);
            if (parsedOutline && parsedOutline.slides) {
                renderOutlinePreview(parsedOutline);
            }
        } catch (e) {
            console.log('å¤§çº²å†…å®¹æ­£åœ¨ç”Ÿæˆä¸­ï¼Œæš‚æ—¶æ— æ³•è§£æä¸ºJSON');
        }

        // Show start PPT generation button
        showStartPPTButton();

    } catch (error) {
        console.error('Error generating file outline:', error);

        // åœæ­¢åŠ è½½åŠ¨ç”»
        stopFunnelAnimation('file');

        contentDiv.innerHTML = `<div style="color: #e74c3c; text-align: center; padding: 20px;">
            <i class="fas fa-exclamation-triangle"></i> è¿æ¥é”™è¯¯: ${error.message}
        </div>`;
        if (placeholderDiv) placeholderDiv.style.display = 'none';

        // é‡ç½®æ ‡å¿—ï¼Œå…è®¸é‡è¯•
        outlineGenerationStarted = false;
    }
}

// New outline generation function for the new UI (non-streaming)
async function startOutlineGenerationNew() {
    console.log('Starting new outline generation (non-streaming)');

    // é˜²æ­¢é‡å¤è°ƒç”¨
    if (outlineGenerationStarted) {
        console.log('Outline generation already started, skipping...');
        return;
    }

    const contentDiv = document.getElementById('outline-content-display');
    const cursorDiv = document.getElementById('outline-cursor');
    const statusDiv = document.getElementById('outline-status');
    const placeholderDiv = document.getElementById('outline-placeholder');

    if (!contentDiv) {
        console.error('Outline content div not found');
        return;
    }

    // æ ‡è®°ä¸ºå·²å¼€å§‹
    outlineGenerationStarted = true;

    // æ˜¾ç¤ºå¢å¼ºçš„åŠ è½½çŠ¶æ€
    if (placeholderDiv) {
        placeholderDiv.innerHTML = `
            <div class="loading-icon">
                <i class="fas fa-brain"></i>
            </div>
            <div class="loading-title">AIæ­£åœ¨ç”ŸæˆPPTå¤§çº²</div>

            <div class="brain-container">
                <div class="ai-brain" id="loading-brain-stream">
                    <div class="brain-core">
                        <div class="brain-icon">ğŸ§ </div>
                    </div>
                    <svg class="progress-ring" width="140" height="140">
                        <circle class="progress-ring-circle" cx="70" cy="70" r="70"></circle>
                        <circle class="progress-ring-progress" cx="70" cy="70" r="70"></circle>
                    </svg>
                    <div class="neural-network">
                        <div class="neural-line" style="--rotation: 45deg;"></div>
                        <div class="neural-line" style="--rotation: -30deg;"></div>
                        <div class="neural-line" style="--rotation: -45deg;"></div>
                        <div class="neural-line" style="--rotation: 60deg;"></div>
                    </div>
                    <div class="thought-bubbles">
                        <div class="thought-bubble"></div>
                        <div class="thought-bubble"></div>
                        <div class="thought-bubble"></div>
                    </div>
                    <div class="text-generation">
                        <div class="generating-text">æ­£åœ¨ç”ŸæˆPPTå¤§çº²</div>
                        <div class="generating-dots">â€¢ â€¢ â€¢</div>
                    </div>
                </div>
            </div>

            <div class="loading-tips">
                <h5><i class="fas fa-lightbulb"></i> å°è´´å£«</h5>
                <p>AIæ­£åœ¨æ ¹æ®æ‚¨çš„éœ€æ±‚æ™ºèƒ½ç”ŸæˆPPTå¤§çº²ï¼ŒåŒ…æ‹¬æ ‡é¢˜ã€å†…å®¹è¦ç‚¹å’Œé€»è¾‘ç»“æ„ã€‚ç”Ÿæˆå®Œæˆåå°†ä¸€æ¬¡æ€§æ˜¾ç¤ºå®Œæ•´å¤§çº²ï¼Œæ‚¨å¯ä»¥ç¼–è¾‘å’Œè°ƒæ•´ã€‚</p>
            </div>
        `;
        placeholderDiv.className = 'loading-container';
        placeholderDiv.style.display = 'block';

        // å¯åŠ¨åŠ¨ç”»
        startBrainAnimation('stream');
    }

    // éšè—å…‰æ ‡å…ƒç´ ï¼ˆéæµå¼ç”Ÿæˆä¸éœ€è¦ï¼‰
    if (cursorDiv) {
        cursorDiv.style.display = 'none';
    }

    // Hide status div during generation
    if (statusDiv) {
        statusDiv.style.display = 'none';
    }

    try {
        // è°ƒç”¨éæµå¼å¤§çº²ç”Ÿæˆæ¥å£
        const response = await fetch(`/projects/${currentProjectId}/generate-outline`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result = await response.json();

        if (result.error) {
            // åœæ­¢åŠ è½½åŠ¨ç”»
            stopBookAnimation('stream');

            // éšè—åŠ è½½çŠ¶æ€
            if (placeholderDiv) {
                placeholderDiv.style.display = 'none';
            }

            contentDiv.innerHTML = `<div style="color: #e74c3c; text-align: center; padding: 20px;">
                <i class="fas fa-exclamation-triangle"></i> é”™è¯¯: ${result.error}
            </div>`;
            if (cursorDiv) cursorDiv.style.display = 'none';

            // é‡ç½®æ ‡å¿—ï¼Œå…è®¸é‡è¯•
            outlineGenerationStarted = false;
            return;
        }

        // åœæ­¢åŠ è½½åŠ¨ç”»
        stopBookAnimation('stream');

        // éšè—åŠ è½½çŠ¶æ€
        if (placeholderDiv) {
            placeholderDiv.style.display = 'none';
        }

        // ä¸€æ¬¡æ€§æ˜¾ç¤ºå®Œæ•´çš„å¤§çº²å†…å®¹
        if (result.outline_content) {
            // æ ¼å¼åŒ–JSONå†…å®¹
            let formattedContent;
            try {
                const parsed = JSON.parse(result.outline_content);
                formattedContent = JSON.stringify(parsed, null, 2);
            } catch (e) {
                formattedContent = result.outline_content;
            }

            // æ˜¾ç¤ºæ ¼å¼åŒ–çš„å†…å®¹
            const preElement = document.createElement('pre');
            preElement.style.cssText = 'margin: 0; font-family: "Consolas", "Monaco", "Courier New", monospace; font-size: 13px; white-space: pre-wrap; word-wrap: break-word;';
            preElement.textContent = formattedContent;
            contentDiv.innerHTML = '';
            contentDiv.appendChild(preElement);
        }

        // é‡ç½®æ ‡å¿—ï¼Œå…è®¸ä¸‹æ¬¡ç”Ÿæˆ
        outlineGenerationStarted = false;

        // Show action buttons
        const actionsDiv = document.getElementById('outline-actions');
        if (actionsDiv) {
            actionsDiv.style.display = 'block';
        }

        // Generate outline view if currently in outline view
        if (currentViewNew === 'outline') {
            setTimeout(() => {
                renderOutlineViewNew();
            }, 500);
        }

        // Show start PPT generation button
        showStartPPTButton();
    } catch (error) {
        console.error('Error streaming outline generation:', error);

        // åœæ­¢åŠ è½½åŠ¨ç”»
        stopFunnelAnimation('stream');

        // éšè—åŠ è½½çŠ¶æ€
        if (placeholderDiv) {
            placeholderDiv.style.display = 'none';
        }

        contentDiv.innerHTML = `<div style="color: #e74c3c; text-align: center; padding: 20px;">
            <i class="fas fa-exclamation-triangle"></i> è¿æ¥é”™è¯¯: ${error.message}
        </div>`;
        if (cursorDiv) cursorDiv.style.display = 'none';
        // Keep status div hidden

        // é‡ç½®æ ‡å¿—ï¼Œå…è®¸é‡è¯•
        outlineGenerationStarted = false;
    }
}

// é‡æ–°ç”Ÿæˆå¤§çº²å‡½æ•°
async function regenerateOutlineNew() {
    console.log('Starting outline regeneration');

    // ç¡®è®¤ç”¨æˆ·æ˜¯å¦è¦é‡æ–°ç”Ÿæˆ
    if (!confirm('ç¡®å®šè¦é‡æ–°ç”Ÿæˆå¤§çº²å—ï¼Ÿè¿™å°†è¦†ç›–å½“å‰çš„å¤§çº²å†…å®¹ã€‚')) {
        return;
    }

    // éšè—æ“ä½œæŒ‰é’®
    const actionsDiv = document.getElementById('outline-actions');
    if (actionsDiv) {
        actionsDiv.style.display = 'none';
    }

    // éšè—å¼€å§‹PPTç”ŸæˆæŒ‰é’®
    hideStartPPTButton();

    // ç¡®ä¿åˆ‡æ¢åˆ°JSONè§†å›¾ä»¥æ˜¾ç¤ºç”Ÿæˆè¿‡ç¨‹
    switchOutlineViewNew('json');

    // æ¸…ç©ºå½“å‰å†…å®¹å¹¶æ˜¾ç¤ºåŠ è½½çŠ¶æ€
    const contentDiv = document.getElementById('outline-content-display');
    const placeholderDiv = document.getElementById('outline-placeholder');

    if (contentDiv) {
        contentDiv.innerHTML = '';
    }

    if (placeholderDiv) {
        placeholderDiv.style.display = 'block';
        placeholderDiv.innerHTML = `
            <div class="loading-icon">
                <i class="fas fa-brain"></i>
            </div>
            <div class="loading-title">æ­£åœ¨é‡æ–°ç”Ÿæˆå¤§çº²</div>

            <div class="brain-container">
                <div class="ai-brain" id="loading-brain-regenerate">
                    <div class="brain-core">
                        <div class="brain-icon">ğŸ§ </div>
                    </div>
                    <svg class="progress-ring" width="140" height="140">
                        <circle class="progress-ring-circle" cx="70" cy="70" r="70"></circle>
                        <circle class="progress-ring-progress" cx="70" cy="70" r="70"></circle>
                    </svg>
                    <div class="neural-network">
                        <div class="neural-line" style="--rotation: 45deg;"></div>
                        <div class="neural-line" style="--rotation: -30deg;"></div>
                        <div class="neural-line" style="--rotation: -45deg;"></div>
                        <div class="neural-line" style="--rotation: 60deg;"></div>
                    </div>
                    <div class="thought-bubbles">
                        <div class="thought-bubble"></div>
                        <div class="thought-bubble"></div>
                        <div class="thought-bubble"></div>
                    </div>
                    <div class="text-generation">
                        <div class="generating-text">æ­£åœ¨é‡æ–°åˆ†æå†…å®¹</div>
                        <div class="generating-dots">â€¢ â€¢ â€¢</div>
                    </div>
                </div>
            </div>

            <div class="loading-tips">
                <h5><i class="fas fa-lightbulb"></i> å°è´´å£«</h5>
                <p>AIæ­£åœ¨é‡æ–°åˆ†ææ‚¨çš„éœ€æ±‚å¹¶ç”Ÿæˆå…¨æ–°çš„PPTå¤§çº²ï¼Œè¯·ç¨å€™...</p>
            </div>
        `;

        // å¯åŠ¨é‡æ–°ç”ŸæˆåŠ¨ç”»
        setTimeout(() => {
            startBrainAnimation('regenerate');
        }, 100);
    }

    // é‡ç½®ç”Ÿæˆæ ‡å¿—
    outlineGenerationStarted = false;

    // é‡ç½®å¤§çº²ç”Ÿæˆé˜¶æ®µçŠ¶æ€ï¼ˆä¸è§¦å‘é¡µé¢é‡æ–°åŠ è½½ï¼‰
    try {
        await updateStageStatusSilent('outline_generation', 'running', 0);
    } catch (error) {
        console.warn('Failed to update stage status:', error);
    }

    // è°ƒç”¨ä¸“é—¨çš„é‡æ–°ç”Ÿæˆå¤§çº²æ¥å£
    try {
        console.log('Calling regenerate outline API');
        const response = await fetch(`/projects/${currentProjectId}/regenerate-outline`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result = await response.json();

        if (result.error) {
            // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
            if (contentDiv) {
                contentDiv.innerHTML = `<div style="color: #e74c3c; text-align: center; padding: 20px;">
                    <i class="fas fa-exclamation-triangle"></i> é”™è¯¯: ${result.error}
                </div>`;
            }
            stopBrainAnimation('regenerate');
            if (placeholderDiv) placeholderDiv.style.display = 'none';

            // é‡æ–°æ˜¾ç¤ºæ“ä½œæŒ‰é’®
            if (actionsDiv) {
                actionsDiv.style.display = 'block';
            }

            // é‡ç½®æ ‡å¿—ï¼Œå…è®¸é‡è¯•
            outlineGenerationStarted = false;
            return;
        }

        // åœæ­¢é‡æ–°ç”ŸæˆåŠ¨ç”»å¹¶éšè—åŠ è½½çŠ¶æ€
        stopBrainAnimation('regenerate');
        if (placeholderDiv) {
            placeholderDiv.style.display = 'none';
        }

        // æ˜¾ç¤ºç”Ÿæˆçš„å¤§çº²å†…å®¹
        if (contentDiv && result.outline_content) {
            const preElement = document.createElement('pre');
            preElement.style.cssText = 'white-space: pre-wrap; word-wrap: break-word; font-family: "Courier New", monospace; font-size: 12px; line-height: 1.4; margin: 0; padding: 0; background: transparent; border: none;';
            preElement.textContent = result.outline_content;
            contentDiv.appendChild(preElement);
        }

        // é‡ç½®æ ‡å¿—ï¼Œå…è®¸ä¸‹æ¬¡ç”Ÿæˆ
        outlineGenerationStarted = false;

        // Show action buttons
        if (actionsDiv) {
            actionsDiv.style.display = 'block';
        }

        // Generate outline view if currently in outline view
        if (currentViewNew === 'outline') {
            setTimeout(() => {
                renderOutlineViewNew();
            }, 500);
        }

        // Show start PPT generation button
        showStartPPTButton();
    } catch (error) {
        console.error('Error during outline regeneration:', error);

        // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
        if (contentDiv) {
            contentDiv.innerHTML = `<div style="color: #e74c3c; text-align: center; padding: 20px;">
                <i class="fas fa-exclamation-triangle"></i> é‡æ–°ç”Ÿæˆå¤±è´¥: ${error.message}
            </div>`;
        }

        stopBrainAnimation('regenerate');
        if (placeholderDiv) {
            placeholderDiv.style.display = 'none';
        }

        // é‡æ–°æ˜¾ç¤ºæ“ä½œæŒ‰é’®
        if (actionsDiv) {
            actionsDiv.style.display = 'block';
        }

        // é‡ç½®æ ‡å¿—ï¼Œå…è®¸é‡è¯•
        outlineGenerationStarted = false;
    }
}

// New outline editing functions for JSON
function editOutlineNew() {
    const contentDiv = document.getElementById('outline-content-display');
    const editArea = document.getElementById('outline-edit-area');
    const editor = document.getElementById('outline-editor');

    if (contentDiv && editArea && editor) {
        // Get current JSON content - ä¼˜å…ˆä»preå…ƒç´ è·å–
        let jsonContent = '';
        const preElement = contentDiv.querySelector('pre');
        if (preElement) {
            jsonContent = preElement.textContent || preElement.innerText || '';
        } else {
            // å¦‚æœæ²¡æœ‰preå…ƒç´ ï¼Œä»æ•´ä¸ªdivè·å–å†…å®¹
            jsonContent = contentDiv.textContent || contentDiv.innerText || '';
        }

        // Try to parse and reformat the JSON for better editing
        try {
            const parsed = JSON.parse(jsonContent);
            jsonContent = JSON.stringify(parsed, null, 2);
        } catch (e) {
            console.warn('Content is not valid JSON, using as-is:', e);
        }

        editor.value = jsonContent;

        // Hide content, show editor
        contentDiv.style.display = 'none';
        editArea.style.display = 'block';
    }
}

function cancelEditOutlineNew() {
    const contentDiv = document.getElementById('outline-content-display');
    const editArea = document.getElementById('outline-edit-area');

    if (contentDiv && editArea) {
        // Show content, hide editor
        contentDiv.style.display = 'block';
        editArea.style.display = 'none';
    }
}

// JSON validation function
function validateJSON() {
    const editor = document.getElementById('outline-editor');
    if (!editor) return;

    try {
        const jsonData = JSON.parse(editor.value);

        // Validate required structure
        if (!jsonData.title) {
            throw new Error('ç¼ºå°‘å¿…éœ€å­—æ®µ: title');
        }
        if (!jsonData.slides || !Array.isArray(jsonData.slides)) {
            throw new Error('ç¼ºå°‘å¿…éœ€å­—æ®µ: slides (å¿…é¡»æ˜¯æ•°ç»„)');
        }

        // Validate each slide
        for (let i = 0; i < jsonData.slides.length; i++) {
            const slide = jsonData.slides[i];
            if (!slide.title) {
                throw new Error(`ç¬¬${i+1}ä¸ªå¹»ç¯ç‰‡ç¼ºå°‘titleå­—æ®µ`);
            }
            if (!slide.content_points || !Array.isArray(slide.content_points)) {
                throw new Error(`ç¬¬${i+1}ä¸ªå¹»ç¯ç‰‡ç¼ºå°‘content_pointså­—æ®µ (å¿…é¡»æ˜¯æ•°ç»„)`);
            }
            if (!slide.slide_type) {
                throw new Error(`ç¬¬${i+1}ä¸ªå¹»ç¯ç‰‡ç¼ºå°‘slide_typeå­—æ®µ`);
            }
        }

        // Format and update editor content
        editor.value = JSON.stringify(jsonData, null, 2);

        alert('âœ… JSONæ ¼å¼éªŒè¯é€šè¿‡ï¼');
        return true;

    } catch (error) {
        alert('âŒ JSONæ ¼å¼é”™è¯¯: ' + error.message);
        return false;
    }
}

async function saveOutlineEditNew() {
    const editor = document.getElementById('outline-editor');
    const contentDiv = document.getElementById('outline-content-display');

    if (!editor || !contentDiv) return;

    // Validate JSON before saving
    if (!validateJSON()) {
        return;
    }

    try {
        const response = await fetch(`/projects/${currentProjectId}/update-outline`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                outline_content: editor.value
            })
        });

        if (response.ok) {
            // Update display content with formatted JSON - ä½¿ç”¨textContenté¿å…HTMLè½¬ä¹‰é—®é¢˜
            const preElement = document.createElement('pre');
            preElement.style.cssText = 'margin: 0; font-family: "Consolas", "Monaco", "Courier New", monospace; font-size: 13px; white-space: pre-wrap; word-wrap: break-word;';
            preElement.textContent = editor.value;
            contentDiv.innerHTML = '';
            contentDiv.appendChild(preElement);

            // Hide editor, show content
            cancelEditOutlineNew();

            // Show success message
            alert('âœ… å¤§çº²å·²æ›´æ–°');

            // ç«‹å³æ›´æ–°å¤§çº²è§†å›¾ï¼Œç¡®ä¿ä½¿ç”¨æœ€æ–°çš„æ•°æ®
            setTimeout(() => {
                // å¼ºåˆ¶åˆ·æ–°å¤§çº²è§†å›¾ï¼Œä½¿ç”¨ç¼–è¾‘å™¨ä¸­çš„æœ€æ–°å†…å®¹
                try {
                    const parsedOutline = JSON.parse(editor.value);

                    // å¦‚æœå½“å‰æ˜¯å¤§çº²è§†å›¾ï¼Œé‡æ–°æ¸²æŸ“
                    if (currentView === 'outline') {
                        renderOutlineView();
                    }

                    // å¦‚æœå½“å‰æ˜¯æ–°çš„å¤§çº²è§†å›¾ï¼Œå¼ºåˆ¶ä½¿ç”¨æœ€æ–°æ•°æ®é‡æ–°æ¸²æŸ“
                    if (currentViewNew === 'outline') {
                        // ç›´æ¥ä¼ é€’è§£æåçš„å¤§çº²æ•°æ®ï¼Œé¿å…ä»DOMé‡æ–°è¯»å–
                        renderOutlineViewNewWithData(parsedOutline);
                    }
                } catch (parseError) {
                    console.error('Failed to parse updated outline:', parseError);
                    // å¦‚æœè§£æå¤±è´¥ï¼Œä»ç„¶å°è¯•å¸¸è§„æ¸²æŸ“
                    if (currentView === 'outline') {
                        renderOutlineView();
                    }
                    if (currentViewNew === 'outline') {
                        renderOutlineViewNew();
                    }
                }
            }, 100); // å‡å°‘å»¶è¿Ÿï¼Œç«‹å³æ›´æ–°
        } else {
            alert('âŒ ä¿å­˜å¤±è´¥ï¼Œè¯·é‡è¯•');
        }
    } catch (error) {
        console.error('Error saving outline:', error);
        alert('âŒ ä¿å­˜å¤±è´¥: ' + error.message);
    }
}

function confirmOutlineNew() {
    if (confirm('ç¡®è®¤å¤§çº²å†…å®¹ï¼Ÿ')) {
        // Mark outline as confirmed
        fetch(`/projects/${currentProjectId}/confirm-outline`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        }).then(response => {
            if (response.ok) {
                // Hide edit/confirm buttons and show start PPT button
                const actionsDiv = document.getElementById('outline-actions');
                if (actionsDiv) {
                    actionsDiv.style.display = 'none';
                }

                // Show start PPT generation button
                showStartPPTButton();
            } else {
                alert('ç¡®è®¤å¤±è´¥ï¼Œè¯·é‡è¯•');
            }
        }).catch(error => {
            console.error('Error confirming outline:', error);
            alert('ç¡®è®¤å¤±è´¥: ' + error.message);
        });
    }
}



// Show start PPT generation button
function showStartPPTButton() {
    // Check if button already exists
    let startPPTButton = document.getElementById('start-ppt-button');

    if (!startPPTButton) {
        // Create start PPT button only if it doesn't exist
        const outlineSection = document.getElementById('outline-section');
        if (outlineSection) {
            startPPTButton = document.createElement('div');
            startPPTButton.id = 'start-ppt-button';
            startPPTButton.style.cssText = 'text-align: center; margin-top: 30px; padding: 20px; background: #e8f5e8; border-radius: 10px; border: 2px solid #27ae60;';

            startPPTButton.innerHTML = `
                <button onclick="startPPTGenerationFromOutline()" class="btn btn-success btn-lg" style="padding: 15px 30px; font-size: 18px;">
                    <i class="fas fa-rocket"></i> å¼€å§‹ç”ŸæˆPPT
                </button>
            `;

            // Insert after outline section
            outlineSection.parentNode.insertBefore(startPPTButton, outlineSection.nextSibling);
        }
    }

    if (startPPTButton) {
        startPPTButton.style.display = 'block';
    }
}

// Hide start PPT generation button
function hideStartPPTButton() {
    const startPPTButton = document.getElementById('start-ppt-button');
    if (startPPTButton) {
        startPPTButton.style.display = 'none';
    }
}

// Start PPT generation from outline
function startPPTGenerationFromOutline() {

    if (confirm('ç¡®è®¤å¼€å§‹ç”ŸæˆPPTï¼Ÿè¿™å°†è·³è½¬åˆ°æ¨¡æ¿é€‰æ‹©é¡µé¢ã€‚')) {
        // Redirect to template selection page
        window.location.href = `/projects/${currentProjectId}/template-selection`;
    }
}

// Start outline generation with streaming
async function startOutlineGeneration() {
    console.log('Starting outline generation with streaming');

    const stageId = 'outline_generation';
    const outputDiv = document.getElementById(`outline-output-${stageId}`);
    const contentDiv = document.getElementById(`outline-content-${stageId}`);
    const cursorDiv = document.getElementById(`outline-cursor-${stageId}`);

    if (!outputDiv || !contentDiv || !cursorDiv) {
        console.error('Outline output elements not found');
        return;
    }

    // Show output area
    outputDiv.style.display = 'block';
    contentDiv.textContent = '';
    cursorDiv.style.display = 'inline-block';

    // Update stage status to running
    const stageElement = document.querySelector(`[data-stage-id="${stageId}"]`);
    if (stageElement) {
        const statusIcon = stageElement.querySelector('.stage-status-icon');
        if (statusIcon) {
            statusIcon.innerHTML = '<div style="display: inline-block; width: 12px; height: 12px; border: 2px solid #f3f3f3; border-top: 2px solid #f39c12; border-radius: 50%; animation: spin 1s linear infinite;"></div>';
        }
    }

    try {
        const response = await fetch(`/projects/${currentProjectId}/outline-stream`);
        const reader = response.body.getReader();
        const decoder = new TextDecoder();

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value);
            const lines = chunk.split('\n');

            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    try {
                        const data = JSON.parse(line.slice(6));

                        if (data.error) {
                            contentDiv.textContent = `é”™è¯¯: ${data.error}`;
                            cursorDiv.style.display = 'none';
                            if (stageElement) {
                                const statusIcon = stageElement.querySelector('.stage-status-icon');
                                if (statusIcon) statusIcon.textContent = 'âŒ';
                            }
                            return;
                        }

                        if (data.content) {
                            contentDiv.textContent += data.content;
                            contentDiv.scrollTop = contentDiv.scrollHeight;
                        }

                        if (data.done) {
                            cursorDiv.style.display = 'none';
                            if (stageElement) {
                                const statusIcon = stageElement.querySelector('.stage-status-icon');
                                if (statusIcon) statusIcon.textContent = 'âœ“';
                            }

                            // æ ¼å¼åŒ–JSONå†…å®¹å¹¶ç”¨preå…ƒç´ åŒ…è£…
                            try {
                                const jsonContent = contentDiv.textContent;
                                const parsed = JSON.parse(jsonContent);
                                const formattedContent = JSON.stringify(parsed, null, 2);

                                // åˆ›å»ºpreå…ƒç´ æ¥æ­£ç¡®æ˜¾ç¤ºJSON
                                const preElement = document.createElement('pre');
                                preElement.style.cssText = 'margin: 0; font-family: "Consolas", "Monaco", "Courier New", monospace; font-size: 13px; white-space: pre-wrap; word-wrap: break-word;';
                                preElement.textContent = formattedContent;
                                contentDiv.innerHTML = '';
                                contentDiv.appendChild(preElement);

                                console.log('Successfully formatted JSON outline with', parsed.slides ? parsed.slides.length : 0, 'slides');
                            } catch (e) {
                                console.warn('Failed to parse JSON content for formatting:', e);
                                // ä¿æŒåŸå§‹å†…å®¹ï¼Œä½†ä»ç„¶ç”¨preåŒ…è£…
                                const preElement = document.createElement('pre');
                                preElement.style.cssText = 'margin: 0; font-family: "Consolas", "Monaco", "Courier New", monospace; font-size: 13px; white-space: pre-wrap; word-wrap: break-word;';
                                preElement.textContent = contentDiv.textContent;
                                contentDiv.innerHTML = '';
                                contentDiv.appendChild(preElement);
                            }

                            // Update the header to show completion
                            const outputDiv = document.getElementById(`outline-output-${stageId}`);
                            if (outputDiv) {
                                const header = outputDiv.querySelector('h6');
                                if (header && !header.querySelector('.completion-badge')) {
                                    const badge = document.createElement('span');
                                    badge.className = 'completion-badge';
                                    badge.style.cssText = 'color: #27ae60; font-size: 0.8em; margin-left: 10px;';
                                    badge.textContent = 'âœ… ç”Ÿæˆå®Œæˆ';
                                    header.appendChild(badge);
                                }
                            }

                            // å»¶è¿Ÿåˆ·æ–°é¡µé¢ï¼Œè®©ç”¨æˆ·æœ‰æ—¶é—´çœ‹åˆ°æ ¼å¼åŒ–çš„å†…å®¹
                            setTimeout(() => {
                                window.location.reload();
                            }, 3000);
                            return;
                        }
                    } catch (e) {
                        console.error('Error parsing outline stream data:', e);
                    }
                }
            }
        }
    } catch (error) {
        console.error('Error streaming outline generation:', error);
        contentDiv.textContent = `è¿æ¥é”™è¯¯: ${error.message}`;
        cursorDiv.style.display = 'none';
        if (stageElement) {
            const statusIcon = stageElement.querySelector('.stage-status-icon');
            if (statusIcon) statusIcon.textContent = 'âŒ';
        }
    }
}

// Start execution for a complete stage
async function startStageExecution(stageId) {
    console.log(`Starting stage execution for: ${stageId}`);

    // Special handling for outline generation
    if (stageId === 'outline_generation') {
        // æ£€æŸ¥æ˜¯å¦å·²ç»å¼€å§‹äº†æ–°çš„å¤§çº²ç”Ÿæˆ
        if (outlineGenerationStarted) {
            console.log('Outline generation already started via new method, skipping stage execution...');
            return;
        }
        return startOutlineGeneration();
    }

    const taskItem = document.querySelector(`[data-stage-id="${stageId}"]`);
    if (!taskItem) {
        console.error(`Task item not found for stage: ${stageId}`);
        return;
    }

    // Check if stage is already running or completed
    const stageStatusIcon = taskItem.querySelector('.stage-status-icon');
    if (stageStatusIcon && (stageStatusIcon.textContent === 'âœ“' || stageStatusIcon.innerHTML.includes('spin'))) {
        console.log(`Stage ${stageId} is already running or completed`);
        return;
    }

    const statusIcon = taskItem.querySelector('.task-status');
    const outputDiv = taskItem.querySelector('.task-output');
    const outputContent = taskItem.querySelector('.output-content');
    const outputCursor = taskItem.querySelector('.output-cursor');
    const streamBtn = taskItem.querySelector('.btn-stream');

    // Update UI
    taskItem.classList.add('active');
    statusIcon.textContent = 'ğŸ”„';
    outputDiv.style.display = 'block';
    outputContent.textContent = '';
    outputCursor.classList.remove('hidden');
    streamBtn.disabled = true;
    streamBtn.textContent = 'å¤„ç†ä¸­...';

    // If this is PPT creation stage, show editor button immediately
    if (stageId === 'ppt_creation') {
        // Show the existing editor button if it exists
        const existingEditorBtn = document.getElementById(`editor-btn-${stageId}`);
        if (existingEditorBtn) {
            existingEditorBtn.style.display = 'inline-block';
            console.log('Editor button shown for PPT creation stage');
        } else {
            // Create new editor button if not exists
            const editorBtn = document.createElement('button');
            editorBtn.onclick = openEditor;
            editorBtn.className = 'editor-btn';
            editorBtn.style.cssText = 'background: #27ae60; color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 0.8em; cursor: pointer; margin-left: 8px;';
            editorBtn.innerHTML = '<i class="fas fa-edit"></i> æ‰“å¼€ç¼–è¾‘å™¨';

            // Insert after the stream button
            if (streamBtn && streamBtn.parentNode) {
                streamBtn.parentNode.insertBefore(editorBtn, streamBtn.nextSibling);
            }

            console.log('Editor button created for PPT creation stage');
        }
    }

    try {
        const response = await fetch(`/projects/${currentProjectId}/stage-stream/${stageId}`);
        const reader = response.body.getReader();
        const decoder = new TextDecoder();

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value);
            const lines = chunk.split('\n');

            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    try {
                        const data = JSON.parse(line.slice(6));

                        if (data.error) {
                            outputContent.textContent = `é”™è¯¯: ${data.error}`;
                            statusIcon.textContent = 'âŒ';
                            streamBtn.disabled = false;
                            streamBtn.textContent = 'é‡è¯•';

                            // If stage is already running or completed, don't show as error
                            if (data.error.includes('already running') || data.error.includes('already completed')) {
                                outputContent.textContent = `æç¤º: ${data.error}`;
                                statusIcon.textContent = 'âš ï¸';
                                streamBtn.style.display = 'none';
                            }
                            break;
                        }

                        if (data.content) {
                            outputContent.textContent += data.content;
                            outputDiv.scrollTop = outputDiv.scrollHeight;
                        }

                        if (data.done) {
                            outputCursor.classList.add('hidden');
                            statusIcon.textContent = 'âœ…';
                            streamBtn.textContent = 'å®Œæˆ';
                            streamBtn.style.display = 'none';

                            // å¦‚æœæ˜¯å¤§çº²ç”Ÿæˆé˜¶æ®µï¼Œæ ¼å¼åŒ–JSONå†…å®¹
                            if (stageId === 'outline_generation') {
                                try {
                                    const jsonContent = outputContent.textContent;
                                    const parsed = JSON.parse(jsonContent);
                                    const formattedContent = JSON.stringify(parsed, null, 2);

                                    // åˆ›å»ºpreå…ƒç´ æ¥æ­£ç¡®æ˜¾ç¤ºJSON
                                    const preElement = document.createElement('pre');
                                    preElement.style.cssText = 'margin: 0; font-family: "Consolas", "Monaco", "Courier New", monospace; font-size: 13px; white-space: pre-wrap; word-wrap: break-word;';
                                    preElement.textContent = formattedContent;
                                    outputContent.innerHTML = '';
                                    outputContent.appendChild(preElement);

                                    console.log('Successfully formatted JSON outline with', parsed.slides ? parsed.slides.length : 0, 'slides');
                                } catch (e) {
                                    console.warn('Failed to parse JSON content for formatting:', e);
                                    // ä¿æŒåŸå§‹å†…å®¹ï¼Œä½†ä»ç„¶ç”¨preåŒ…è£…
                                    const preElement = document.createElement('pre');
                                    preElement.style.cssText = 'margin: 0; font-family: "Consolas", "Monaco", "Courier New", monospace; font-size: 13px; white-space: pre-wrap; word-wrap: break-word;';
                                    preElement.textContent = outputContent.textContent;
                                    outputContent.innerHTML = '';
                                    outputContent.appendChild(preElement);
                                }
                            }

                            // If this is PPT creation stage, update editor button text
                            if (stageId === 'ppt_creation') {
                                const existingEditorBtn = taskItem.querySelector('.editor-btn');
                                if (existingEditorBtn) {
                                    existingEditorBtn.innerHTML = '<i class="fas fa-edit"></i> æŸ¥çœ‹PPT';
                                    console.log('Updated editor button text to "æŸ¥çœ‹PPT"');
                                }
                            }

                            // Refresh the page to show updated progress
                            setTimeout(() => {
                                window.location.reload();
                            }, 2000);
                            break;
                        }
                    } catch (e) {
                        console.error('Error parsing stream data:', e);
                    }
                }
            }
        }
    } catch (error) {
        console.error('Error streaming stage:', error);
        outputContent.textContent = `è¿æ¥é”™è¯¯: ${error.message}`;
        statusIcon.textContent = 'âŒ';
    } finally {
        streamBtn.disabled = false;
        if (streamBtn.textContent === 'å¤„ç†ä¸­...') {
            streamBtn.textContent = 'é‡è¯•';
        }
    }
}

function startStage(stageId) {
    updateStageStatus(stageId, 'running');
}

function completeStage(stageId) {
    updateStageStatus(stageId, 'completed', 100);
}

function retryStage(stageId) {
    updateStageStatus(stageId, 'running', 0);
}

// Continue from a specific stage - reset all subsequent stages and start from the selected stage
async function continueFromStage(stageId) {
    console.log(`Continue from stage: ${stageId}`);

    // Show confirmation dialog
    const confirmMessage = `ç¡®å®šè¦ä»"${getStageDisplayName(stageId)}"æ­¥éª¤é‡æ–°å¼€å§‹å—ï¼Ÿ\n\nè¿™å°†é‡ç½®è¯¥æ­¥éª¤åŠä¹‹åçš„æ‰€æœ‰æ­¥éª¤ï¼Œå¹¶é‡æ–°æ‰§è¡Œå·¥ä½œæµç¨‹ã€‚`;

    if (!confirm(confirmMessage)) {
        return;
    }

    try {
        // Call backend API to reset stages from the selected stage
        const response = await fetch(`/api/projects/${currentProjectId}/continue-from-stage`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                stage_id: stageId
            })
        });

        if (response.ok) {
            const result = await response.json();

            // Show success message
            alert(`å·²ä»"${getStageDisplayName(stageId)}"æ­¥éª¤é‡æ–°å¼€å§‹ï¼Œæ­£åœ¨é‡æ–°æ‰§è¡Œå·¥ä½œæµç¨‹...`);

            // Reload page to show updated status
            setTimeout(() => {
                window.location.reload();
            }, 1000);
        } else {
            const error = await response.json();
            throw new Error(error.detail || 'é‡æ–°å¼€å§‹å¤±è´¥');
        }
    } catch (error) {
        console.error('Error continuing from stage:', error);
        alert('é‡æ–°å¼€å§‹å¤±è´¥: ' + error.message);
    }
}

// Get display name for stage ID
function getStageDisplayName(stageId) {
    const stageNames = {
        'requirements_confirmation': 'éœ€æ±‚ç¡®è®¤',
        'outline_generation': 'å¤§çº²ç”Ÿæˆ',
        'theme_configuration': 'ä¸»é¢˜é…ç½®',
        'content_enhancement': 'å†…å®¹å¢å¼º',
        'ppt_creation': 'PPTç”Ÿæˆ',
        'quality_review': 'è´¨é‡å®¡æ ¸'
    };

    return stageNames[stageId] || stageId;
}

async function updateStageStatus(stageId, status, progress = null) {
    try {
        const response = await fetch(`/api/projects/${currentProjectId}/stages/${stageId}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                status: status,
                progress: progress
            })
        });

        if (response.ok) {
            // Reload page to show updated status
            setTimeout(() => {
                window.location.reload();
            }, 500);
        } else {
            alert('æ›´æ–°å¤±è´¥ï¼Œè¯·é‡è¯•');
        }
    } catch (error) {
        console.error('Error updating stage:', error);
        alert('æ›´æ–°å¤±è´¥: ' + error.message);
    }
}

// Silent version that doesn't reload the page (for regeneration scenarios)
async function updateStageStatusSilent(stageId, status, progress = null) {
    try {
        const response = await fetch(`/api/projects/${currentProjectId}/stages/${stageId}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                status: status,
                progress: progress
            })
        });

        if (!response.ok) {
            console.warn('Failed to update stage status silently');
        }
    } catch (error) {
        console.error('Error updating stage silently:', error);
    }
}

// Subtask management functions removed - now using complete stage execution

// Real-time updates
setInterval(async function() {
    try {
        const response = await fetch(`/api/projects/${currentProjectId}/todo`);
        const todoData = await response.json();

        // Update overall progress
        const progressBar = document.querySelector('.overall-progress-bar');
        const progressText = document.querySelector('.overall-progress-text');
        const progressDetails = document.querySelector('.progress-details');

        if (progressBar && progressText && todoData.overall_progress !== undefined) {
            progressBar.style.width = todoData.overall_progress + '%';
            progressText.textContent = `æ€»ä½“è¿›åº¦: ${todoData.overall_progress.toFixed(1)}%`;
        }

        if (progressDetails && todoData.stages && Array.isArray(todoData.stages)) {
            const completedStages = todoData.stages.filter(s => s.status === 'completed').length;
            progressDetails.textContent = `å·²å®Œæˆ ${completedStages} / ${todoData.stages.length} ä¸ªé˜¶æ®µ`;
        }

        // Hide connection error if update is successful
        const errorElement = document.getElementById('connection-error');
        if (errorElement) {
            errorElement.style.display = 'none';
        }

        // Update stage indicators
        if (todoData.stages && Array.isArray(todoData.stages)) {
            todoData.stages.forEach(stage => {
            const stageElement = document.querySelector(`[data-stage-id="${stage.id}"]`);
            if (stageElement) {
                const icon = stageElement.querySelector('.stage-status-icon');
                const progressBar = stageElement.querySelector('.stage-progress-bar');
                const progressText = stageElement.querySelector('.stage-progress-text');
                const taskStatus = stageElement.querySelector('.task-status');

                // Update status icon
                if (stage.status === 'completed') {
                    icon.textContent = 'âœ“';
                    icon.parentElement.style.background = '#27ae60';
                    if (taskStatus) taskStatus.textContent = 'âœ…';

                    // Auto-start outline generation when requirements confirmation is completed
                    if (stage.id === 'requirements_confirmation') {
                        const outlineStage = document.querySelector('[data-stage-id="outline_generation"]');
                        const outlineStatus = outlineStage?.querySelector('.stage-status-icon')?.textContent;
                        if (outlineStatus === 'â³') {
                            console.log('Requirements just completed, starting outline generation');
                            setTimeout(() => {
                                startStageExecution('outline_generation');
                            }, 2000); // Wait 2 seconds for UI to update
                        }
                    }
                } else if (stage.status === 'running') {
                    icon.innerHTML = '<div style="width: 16px; height: 16px; border: 2px solid white; border-top: 2px solid transparent; border-radius: 50%; animation: spin 1s linear infinite;"></div>';
                    icon.parentElement.style.background = '#3498db';
                    if (taskStatus) taskStatus.textContent = 'ğŸ”„';

                    // Show editor button for PPT creation stage when it starts running
                    if (stage.id === 'ppt_creation') {
                        const editorBtn = document.getElementById(`editor-btn-${stage.id}`);
                        if (editorBtn) {
                            editorBtn.style.display = 'inline-block';
                        }
                    }
                } else if (stage.status === 'failed') {
                    icon.textContent = 'âœ—';
                    icon.parentElement.style.background = '#e74c3c';
                    if (taskStatus) taskStatus.textContent = 'âŒ';
                }

                // Update progress bar
                if (progressBar && progressText && stage.status === 'running') {
                    progressBar.style.width = stage.progress + '%';
                    progressText.textContent = stage.progress.toFixed(1) + '%';
                }
            }
        });
        }

    } catch (error) {
        console.error('Error updating TODO board:', error);
        // Show connection error message
        const errorElement = document.getElementById('connection-error');
        if (errorElement) {
            errorElement.style.display = 'block';
            errorElement.textContent = 'è¿æ¥é”™è¯¯ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•';
        }
    }
}, 3000); // Update every 3 seconds

// Modal functionality removed - using direct stage execution

// Open editor function
function openEditor() {
    console.log(`Opening editor for project: ${currentProjectId}`);
    const editorUrl = `/projects/${currentProjectId}/edit`;
    console.log(`Editor URL: ${editorUrl}`);
    window.open(editorUrl, '_blank');
}

// Auto-start workflow when page loads
document.addEventListener('DOMContentLoaded', function() {
    // Check if we just came from requirements confirmation (URL parameter or session storage)
    const urlParams = new URLSearchParams(window.location.search);
    const fromRequirements = urlParams.get('from_requirements') === 'true' ||
                            sessionStorage.getItem('requirements_just_confirmed') === 'true';

    // Clear the session storage flag
    sessionStorage.removeItem('requirements_just_confirmed');

    // Check requirements confirmation status and outline generation status
    const requirementsStage = document.querySelector('[data-stage-id="requirements_confirmation"]');
    const outlineStage = document.querySelector('[data-stage-id="outline_generation"]');

    const requirementsCompleted = requirementsStage?.querySelector('.stage-status-icon')?.textContent === 'âœ“';
    const outlineStatus = outlineStage?.querySelector('.stage-status-icon')?.textContent;

    // Auto-start outline generation if requirements just confirmed or if requirements completed and outline pending
    if ((fromRequirements || requirementsCompleted) && outlineStatus === 'â³') {
        // Requirements confirmed, automatically start outline generation (second step)
        console.log('Requirements confirmed, starting outline generation automatically');
        // åªæœ‰åœ¨ä¸æ˜¯æ¥è‡ªéœ€æ±‚ç¡®è®¤é¡µé¢æ—¶æ‰è°ƒç”¨ï¼Œé¿å…é‡å¤è°ƒç”¨
        if (!fromRequirements) {
            setTimeout(() => {
                startOutlineGenerationNew();
            }, 1000);
        }
    } else if (!requirementsCompleted) {
        // Check if this is a new project (all stages are pending)
        const stages = document.querySelectorAll('.todo-stage');
        let allPending = true;

        stages.forEach(stage => {
            const statusIcon = stage.querySelector('.stage-status-icon');
            if (statusIcon && statusIcon.textContent !== 'â³') {
                allPending = false;
            }
        });

        if (allPending) {
            // Start the workflow automatically for requirements confirmation
            setTimeout(() => {
                fetch(`/projects/${currentProjectId}/start-workflow`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                }).then(response => {
                    if (response.ok) {
                        console.log('Workflow started automatically');
                    } else {
                        console.error('Failed to start workflow');
                    }
                }).catch(error => {
                    console.error('Error starting workflow:', error);
                });
            }, 2000); // Wait 2 seconds after page load
        }
    }
});

// Sequential stage execution - simplified to not interfere with backend workflow
async function startSequentialStageExecution() {
    console.log('Workflow started automatically');
    // The backend workflow will handle the actual execution
    // Frontend just monitors progress through real-time updates
}

// Execute a single stage and wait for completion
async function executeStageAndWait(stageId) {
    return new Promise((resolve, reject) => {
        const taskItem = document.querySelector(`[data-stage-id="${stageId}"]`);
        if (!taskItem) {
            resolve();
            return;
        }

        const statusIcon = taskItem.querySelector('.task-status');
        const outputDiv = taskItem.querySelector('.task-output');
        const outputContent = taskItem.querySelector('.output-content');
        const outputCursor = taskItem.querySelector('.output-cursor');
        const streamBtn = taskItem.querySelector('.btn-stream');

        // Update UI
        taskItem.classList.add('active');
        statusIcon.textContent = 'ğŸ”„';
        outputDiv.style.display = 'block';
        outputContent.textContent = '';
        outputCursor.classList.remove('hidden');
        if (streamBtn) {
            streamBtn.disabled = true;
            streamBtn.textContent = 'å¤„ç†ä¸­...';
        }

        // Start streaming
        fetch(`/projects/${currentProjectId}/stage-stream/${stageId}`)
            .then(response => response.body.getReader())
            .then(reader => {
                const decoder = new TextDecoder();

                function readStream() {
                    return reader.read().then(({ done, value }) => {
                        if (done) {
                            // Stream completed
                            outputCursor.classList.add('hidden');
                            statusIcon.textContent = 'âœ…';
                            if (streamBtn) {
                                streamBtn.textContent = 'å®Œæˆ';
                                streamBtn.disabled = false;
                                streamBtn.style.display = 'none';
                            }

                            // Small delay before resolving to ensure UI updates
                            setTimeout(() => {
                                resolve();
                            }, 500);
                            return;
                        }

                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n');

                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                try {
                                    const data = JSON.parse(line.slice(6));

                                    if (data.error) {
                                        outputContent.textContent = `é”™è¯¯: ${data.error}`;
                                        statusIcon.textContent = 'âŒ';
                                        reject(new Error(data.error));
                                        return;
                                    }

                                    if (data.content) {
                                        outputContent.textContent += data.content;
                                        outputDiv.scrollTop = outputDiv.scrollHeight;
                                    }

                                    if (data.done) {
                                        outputCursor.classList.add('hidden');
                                        statusIcon.textContent = 'âœ…';
                                        if (streamBtn) {
                                            streamBtn.textContent = 'å®Œæˆ';
                                            streamBtn.disabled = false;
                                        }

                                        // å¦‚æœæ˜¯å¤§çº²ç”Ÿæˆç›¸å…³çš„æµå¼å¤„ç†ï¼Œæ ¼å¼åŒ–JSONå†…å®¹
                                        if (stageId === 'outline_generation' || outputContent.textContent.trim().startsWith('{')) {
                                            try {
                                                const jsonContent = outputContent.textContent;
                                                const parsed = JSON.parse(jsonContent);
                                                const formattedContent = JSON.stringify(parsed, null, 2);

                                                // åˆ›å»ºpreå…ƒç´ æ¥æ­£ç¡®æ˜¾ç¤ºJSON
                                                const preElement = document.createElement('pre');
                                                preElement.style.cssText = 'margin: 0; font-family: "Consolas", "Monaco", "Courier New", monospace; font-size: 13px; white-space: pre-wrap; word-wrap: break-word;';
                                                preElement.textContent = formattedContent;
                                                outputContent.innerHTML = '';
                                                outputContent.appendChild(preElement);

                                                console.log('Successfully formatted JSON content with', parsed.slides ? parsed.slides.length : 0, 'slides');
                                            } catch (e) {
                                                console.warn('Failed to parse JSON content for formatting:', e);
                                                // ä¿æŒåŸå§‹å†…å®¹ï¼Œä½†ä»ç„¶ç”¨preåŒ…è£…
                                                const preElement = document.createElement('pre');
                                                preElement.style.cssText = 'margin: 0; font-family: "Consolas", "Monaco", "Courier New", monospace; font-size: 13px; white-space: pre-wrap; word-wrap: break-word;';
                                                preElement.textContent = outputContent.textContent;
                                                outputContent.innerHTML = '';
                                                outputContent.appendChild(preElement);
                                            }
                                        }

                                        resolve();
                                        return;
                                    }
                                } catch (e) {
                                    console.error('Error parsing stream data:', e);
                                }
                            }
                        }

                        return readStream();
                    });
                }

                return readStream();
            })
            .catch(error => {
                console.error('Error streaming subtask:', error);
                outputContent.textContent = `è¿æ¥é”™è¯¯: ${error.message}`;
                statusIcon.textContent = 'âŒ';
                if (streamBtn) {
                    streamBtn.disabled = false;
                    streamBtn.textContent = 'é‡è¯•';
                }
                reject(error);
            });
    });
}

// Update stage visual status
function updateStageVisualStatus(stageElement, status) {
    const statusIcon = stageElement.querySelector('.stage-status-icon');
    const progressBar = stageElement.querySelector('.stage-progress-bar');

    if (status === 'running') {
        if (statusIcon) statusIcon.textContent = 'ğŸ”„';
        if (progressBar) progressBar.style.width = '50%';
        stageElement.style.borderLeft = '4px solid #f39c12';
    } else if (status === 'completed') {
        if (statusIcon) statusIcon.textContent = 'âœ…';
        if (progressBar) progressBar.style.width = '100%';
        stageElement.style.borderLeft = '4px solid #27ae60';
    }
}


let currentView = 'outline';
let mindmapData = null;
let selectedNode = null;
let editingNode = null;
let mindmapSvg = null;
let mindmapZoom = null;

// åˆ‡æ¢å¤§çº²è§†å›¾ï¼ˆJSONç¼–è¾‘å™¨ vs å¤§çº²è§†å›¾ï¼‰
function switchOutlineView(viewType) {
    const jsonView = document.getElementById('json-view');
    const outlineView = document.getElementById('outline-view');
    const jsonBtn = document.getElementById('json-view-btn');
    const outlineBtn = document.getElementById('outline-view-btn');

    if (viewType === 'json') {
        // åˆ‡æ¢åˆ°JSONè§†å›¾
        if (jsonView) jsonView.style.display = 'block';
        if (outlineView) outlineView.style.display = 'none';

        // æ›´æ–°æŒ‰é’®æ ·å¼
        if (jsonBtn) {
            jsonBtn.style.background = '#3498db';
            jsonBtn.style.color = 'white';
        }
        if (outlineBtn) {
            outlineBtn.style.background = 'transparent';
            outlineBtn.style.color = '#6c757d';
        }

        currentView = 'json';
    } else if (viewType === 'outline') {
        // åˆ‡æ¢åˆ°å¤§çº²è§†å›¾
        if (jsonView) jsonView.style.display = 'none';
        if (outlineView) outlineView.style.display = 'block';

        // æ›´æ–°æŒ‰é’®æ ·å¼
        if (outlineBtn) {
            outlineBtn.style.background = '#3498db';
            outlineBtn.style.color = 'white';
        }
        if (jsonBtn) {
            jsonBtn.style.background = 'transparent';
            jsonBtn.style.color = '#6c757d';
        }

        currentView = 'outline';

        // æ¸²æŸ“å¤§çº²è§†å›¾
        renderOutlineView();
    }
}

// æ¸²æŸ“å¤§çº²è§†å›¾
function renderOutlineView() {
    const outlineContent = getOutlineContent();
    if (!outlineContent) {
        console.log('No outline content available');
        return;
    }

    try {
        const parsedOutline = JSON.parse(outlineContent);
        if (parsedOutline && parsedOutline.slides) {
            renderOutlinePreview(parsedOutline);
        }
    } catch (e) {
        console.log('Failed to parse outline content for view rendering');
    }
}

// è·å–å¤§çº²å†…å®¹
function getOutlineContent() {
    const outlineDisplay = document.getElementById('outline-content-display');
    if (!outlineDisplay) return null;

    const preElement = outlineDisplay.querySelector('pre');
    if (preElement) {
        let content = preElement.textContent || preElement.innerText || '';
        return content.trim();
    }

    // å¦‚æœæ²¡æœ‰preå…ƒç´ ï¼Œä»æ•´ä¸ªdivè·å–å†…å®¹å¹¶å¤„ç†HTMLå®ä½“
    let content = outlineDisplay.textContent || outlineDisplay.innerText || '';
    content = content.replace(/&nbsp;/g, ' ').replace(/\s+/g, ' ');
    return content.trim();
}


// ========== å¤§çº²é¢„è§ˆåŠŸèƒ½ ==========

let isDetailView = false;
let currentOutlineData = null;

// åˆ‡æ¢å¤§çº²è§†å›¾ï¼ˆç®€æ´è§†å›¾ vs è¯¦ç»†è§†å›¾ï¼‰
function toggleOutlineView() {
    const compactView = document.getElementById('compactView');
    const detailView = document.getElementById('detailView');
    const toggleText = document.getElementById('viewToggleText');

    if (isDetailView) {
        compactView.style.display = 'block';
        detailView.style.display = 'none';
        toggleText.textContent = 'è¯¦ç»†è§†å›¾';
        isDetailView = false;
    } else {
        compactView.style.display = 'none';
        detailView.style.display = 'block';
        toggleText.textContent = 'ç®€æ´è§†å›¾';
        isDetailView = true;
    }
}

// æ¸²æŸ“å¤§çº²é¢„è§ˆ
function renderOutlinePreview(outlineData) {
    if (!outlineData) return;

    currentOutlineData = outlineData;

    // éšè—ç©ºçŠ¶æ€ï¼Œæ˜¾ç¤ºå†…å®¹
    const emptyDiv = document.getElementById('outline-empty');
    const loadingDiv = document.getElementById('outline-loading');
    if (emptyDiv) emptyDiv.style.display = 'none';
    if (loadingDiv) loadingDiv.style.display = 'none';

    // æ¸²æŸ“ç®€æ´è§†å›¾
    renderCompactView(outlineData);

    // æ¸²æŸ“è¯¦ç»†è§†å›¾
    renderDetailView(outlineData);
}

// æ¸²æŸ“ç®€æ´è§†å›¾
function renderCompactView(outlineData) {
    const container = document.getElementById('outline-slides-compact');
    if (!container || !outlineData.slides) return;

    container.innerHTML = '';

    outlineData.slides.forEach((slide, index) => {
        const slideCard = document.createElement('div');
        slideCard.style.cssText = `
            padding: 15px; background: white; border-radius: 8px;
            border-left: 4px solid #3498db; transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); position: relative;
            cursor: pointer;
        `;

        slideCard.onmouseover = function() {
            this.style.transform = 'translateY(-2px)';
            this.style.boxShadow = '0 4px 8px rgba(0,0,0,0.15)';
        };
        slideCard.onmouseout = function() {
            this.style.transform = 'translateY(0)';
            this.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
        };

        const contentPoints = slide.content_points || slide.content || [];
        const firstPoint = Array.isArray(contentPoints) ? contentPoints[0] : contentPoints;
        const remainingCount = Array.isArray(contentPoints) ? Math.max(0, contentPoints.length - 1) : 0;

        slideCard.innerHTML = `
            <div style="display: flex; align-items: center; margin-bottom: 8px;">
                <span style="background: #3498db; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-size: 0.8em; font-weight: bold; margin-right: 10px;">
                    ${slide.page_number || index + 1}
                </span>
                <strong style="color: #2c3e50; font-size: 0.9em;">${slide.title || 'æœªå‘½åå¹»ç¯ç‰‡'}</strong>
            </div>
            ${slide.subtitle ? `<p style="color: #7f8c8d; font-size: 0.8em; margin: 5px 0; font-style: italic;">${slide.subtitle}</p>` : ''}
            <div style="color: #666; font-size: 0.8em; line-height: 1.4;">
                ${firstPoint ? (typeof firstPoint === 'string' ? firstPoint.substring(0, 80) + (firstPoint.length > 80 ? '...' : '') : JSON.stringify(firstPoint).substring(0, 80) + '...') : '<span style="color: #95a5a6;">æš‚æ— å†…å®¹</span>'}
                ${remainingCount > 0 ? `<br><span style="color: #95a5a6;">+${remainingCount} ä¸ªè¦ç‚¹</span>` : ''}
            </div>
        `;

        slideCard.onclick = () => viewSlideDetail(index);
        container.appendChild(slideCard);
    });
}

// æ¸²æŸ“è¯¦ç»†è§†å›¾
function renderDetailView(outlineData) {
    const container = document.getElementById('outline-slides-detail');
    if (!container || !outlineData.slides) return;

    container.innerHTML = '';

    outlineData.slides.forEach((slide, index) => {
        const slideDiv = document.createElement('div');
        slideDiv.style.cssText = `
            padding: 20px; margin-bottom: 15px; background: #f8f9fa;
            border-radius: 10px; border-left: 4px solid #3498db; position: relative;
        `;

        const contentPoints = slide.content_points || slide.content || [];
        let contentHtml = '';

        if (Array.isArray(contentPoints) && contentPoints.length > 0) {
            contentHtml = `
                <div style="margin-top: 10px;">
                    <h5 style="color: #555; margin-bottom: 8px; font-size: 0.9em;">å†…å®¹è¦ç‚¹ï¼š</h5>
                    <ul style="margin: 0; padding-left: 20px; color: #555; line-height: 1.6;">
                        ${contentPoints.map(point => `<li style="margin-bottom: 5px;">${point}</li>`).join('')}
                    </ul>
                </div>
            `;
        } else if (contentPoints) {
            contentHtml = `
                <div style="margin-top: 10px;">
                    <h5 style="color: #555; margin-bottom: 8px; font-size: 0.9em;">å†…å®¹ï¼š</h5>
                    <div style="background: white; padding: 15px; border-radius: 6px; color: #555; line-height: 1.6; white-space: pre-wrap;">${contentPoints}</div>
                </div>
            `;
        }

        slideDiv.innerHTML = `
            <div style="display: flex; align-items: center; margin-bottom: 15px;">
                <span style="background: #3498db; color: white; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-weight: bold; margin-right: 15px;">
                    ${slide.page_number || index + 1}
                </span>
                <div style="flex: 1;">
                    <strong style="color: #2c3e50; font-size: 1.1em;">${slide.title || 'æœªå‘½åå¹»ç¯ç‰‡'}</strong>
                    ${slide.subtitle ? `<br><em style="color: #7f8c8d; font-size: 0.9em;">${slide.subtitle}</em>` : ''}
                </div>
            </div>
            ${contentHtml}
            ${slide.slide_type ? `<div style="margin-top: 10px;"><span style="background: #e8f4fd; color: #3498db; padding: 4px 8px; border-radius: 4px; font-size: 0.8em;">ç±»å‹: ${slide.slide_type}</span></div>` : ''}
        `;

        container.appendChild(slideDiv);
    });
}

// æŸ¥çœ‹å¹»ç¯ç‰‡è¯¦æƒ…
function viewSlideDetail(slideIndex) {
    if (!currentOutlineData || !currentOutlineData.slides || !currentOutlineData.slides[slideIndex]) return;

    const slide = currentOutlineData.slides[slideIndex];

    // åˆ›å»ºæ¨¡æ€æ¡†æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.5); z-index: 1000; display: flex;
        align-items: center; justify-content: center; padding: 20px;
    `;

    const content = document.createElement('div');
    content.style.cssText = `
        background: white; border-radius: 15px; padding: 30px;
        max-width: 600px; max-height: 80vh; overflow-y: auto;
        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    `;

    const contentPoints = slide.content_points || slide.content || [];
    let contentHtml = '';

    if (Array.isArray(contentPoints) && contentPoints.length > 0) {
        contentHtml = `
            <h5 style="color: #555; margin: 15px 0 8px 0;">å†…å®¹è¦ç‚¹ï¼š</h5>
            <ul style="margin: 0; padding-left: 20px; color: #555; line-height: 1.6;">
                ${contentPoints.map(point => `<li style="margin-bottom: 5px;">${point}</li>`).join('')}
            </ul>
        `;
    } else if (contentPoints) {
        contentHtml = `
            <h5 style="color: #555; margin: 15px 0 8px 0;">å†…å®¹ï¼š</h5>
            <div style="background: #f8f9fa; padding: 15px; border-radius: 6px; color: #555; line-height: 1.6; white-space: pre-wrap;">${contentPoints}</div>
        `;
    }

    content.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="color: #2c3e50; margin: 0;">ç¬¬${slide.page_number || slideIndex + 1}é¡µè¯¦æƒ…</h3>
            <button onclick="this.closest('.modal').remove()" style="background: #e74c3c; color: white; border: none; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; font-size: 16px;">Ã—</button>
        </div>
        <h4 style="color: #3498db; margin-bottom: 10px;">${slide.title || 'æœªå‘½åå¹»ç¯ç‰‡'}</h4>
        ${slide.subtitle ? `<p style="color: #7f8c8d; font-style: italic; margin-bottom: 15px;">${slide.subtitle}</p>` : ''}
        ${contentHtml}
        ${slide.slide_type ? `<div style="margin-top: 15px;"><span style="background: #e8f4fd; color: #3498db; padding: 6px 12px; border-radius: 6px; font-size: 0.9em;">ç±»å‹: ${slide.slide_type}</span></div>` : ''}
    `;

    modal.className = 'modal';
    modal.appendChild(content);
    document.body.appendChild(modal);

    // ç‚¹å‡»èƒŒæ™¯å…³é—­
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            modal.remove();
        }
    });
}

// ç¼–è¾‘å¤§çº²å†…å®¹
function editOutlineContent() {
    // è·å–å½“å‰å¤§çº²å†…å®¹
    let outlineContent = '';
    if (currentOutlineData) {
        outlineContent = JSON.stringify(currentOutlineData, null, 2);
    } else {
        // å°è¯•ä»æ˜¾ç¤ºåŒºåŸŸè·å–å†…å®¹
        const outlineDisplay = document.getElementById('outline-content-display');
        if (outlineDisplay) {
            outlineContent = outlineDisplay.textContent || outlineDisplay.innerText || '';
        }
    }

    // åˆ›å»ºç¼–è¾‘æ¨¡æ€æ¡†
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.5); z-index: 1000; display: flex;
        align-items: center; justify-content: center; padding: 20px;
    `;

    const content = document.createElement('div');
    content.style.cssText = `
        background: white; border-radius: 15px; padding: 30px;
        width: 90%; max-width: 800px; height: 80vh; display: flex;
        flex-direction: column; box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    `;

    content.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="color: #2c3e50; margin: 0;">ç¼–è¾‘PPTå¤§çº²</h3>
            <button onclick="this.closest('.modal').remove()" style="background: #e74c3c; color: white; border: none; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; font-size: 16px;">Ã—</button>
        </div>
        <div style="flex: 1; display: flex; flex-direction: column;">
            <textarea id="outlineEditor" style="flex: 1; border: 2px solid #ecf0f1; border-radius: 8px; padding: 15px; font-family: 'Courier New', monospace; font-size: 14px; line-height: 1.5; resize: none;" placeholder="ç¼–è¾‘å¤§çº²JSON...">${outlineContent}</textarea>
            <div style="display: flex; gap: 8px; margin-top: 15px; justify-content: flex-end;">
                <button onclick="this.closest('.modal').remove()" class="btn btn-sm" style="background: #95a5a6; color: white;">å–æ¶ˆ</button>
                <button onclick="saveOutlineChanges()" class="btn btn-sm btn-primary">ä¿å­˜ä¿®æ”¹</button>
            </div>
        </div>
    `;

    modal.className = 'modal';
    modal.appendChild(content);
    document.body.appendChild(modal);
}

// ä¿å­˜å¤§çº²ä¿®æ”¹
function saveOutlineChanges() {
    const editor = document.getElementById('outlineEditor');
    if (!editor) return;

    try {
        const newOutline = JSON.parse(editor.value);

        // æ›´æ–°å½“å‰å¤§çº²æ•°æ®
        currentOutlineData = newOutline;

        // é‡æ–°æ¸²æŸ“é¢„è§ˆ
        renderOutlinePreview(newOutline);

        // æ›´æ–°JSONæ˜¾ç¤ºåŒºåŸŸ
        const outlineDisplay = document.getElementById('outline-content-display');
        if (outlineDisplay) {
            const formattedContent = JSON.stringify(newOutline, null, 2);
            const preElement = document.createElement('pre');
            preElement.style.cssText = 'margin: 0; font-family: "Consolas", "Monaco", "Courier New", monospace; font-size: 13px; white-space: pre-wrap; word-wrap: break-word;';
            preElement.textContent = formattedContent;
            outlineDisplay.innerHTML = '';
            outlineDisplay.appendChild(preElement);
        }

        // ä¿å­˜åˆ°æœåŠ¡å™¨
        fetch(`/projects/${currentProjectId}/update-outline`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                outline_content: JSON.stringify(newOutline, null, 2)
            })
        }).then(response => {
            if (response.ok) {
                alert('å¤§çº²ä¿®æ”¹æˆåŠŸï¼');
                // å…³é—­æ¨¡æ€æ¡†
                document.querySelector('.modal').remove();

                // ç«‹å³é‡æ–°æ¸²æŸ“å¤§çº²è§†å›¾ï¼Œä½¿ç”¨æœ€æ–°æ•°æ®
                setTimeout(() => {
                    // å¦‚æœå½“å‰æ˜¯å¤§çº²è§†å›¾ï¼Œé‡æ–°æ¸²æŸ“
                    if (currentView === 'outline') {
                        renderOutlineView();
                    }

                    // å¦‚æœå½“å‰æ˜¯æ–°çš„å¤§çº²è§†å›¾ï¼Œä½¿ç”¨æœ€æ–°æ•°æ®é‡æ–°æ¸²æŸ“
                    if (currentViewNew === 'outline') {
                        renderOutlineViewNewWithData(newOutline);
                    }
                }, 100); // å‡å°‘å»¶è¿Ÿ
            } else {
                alert('ä¿å­˜å¤±è´¥ï¼Œè¯·é‡è¯•');
            }
        }).catch(error => {
            console.error('Error saving outline:', error);
            alert('ä¿å­˜å¤±è´¥: ' + error.message);
        });

    } catch (error) {
        if (error instanceof SyntaxError) {
            alert('JSONæ ¼å¼é”™è¯¯ï¼Œè¯·æ£€æŸ¥è¯­æ³•ï¼');
        } else {
            console.error('Error saving outline:', error);
            alert('ä¿å­˜å¤±è´¥: ' + error.message);
        }
    }
}

// å¯¼å‡ºå¤§çº²ä¸ºJSONæ–‡ä»¶
function exportOutlineJSON() {
    if (!currentOutlineData) {
        alert('å¤§çº²æ•°æ®ä¸å­˜åœ¨ï¼Œæ— æ³•å¯¼å‡º');
        return;
    }

    const dataStr = JSON.stringify(currentOutlineData, null, 2);
    const dataBlob = new Blob([dataStr], {type: 'application/json'});

    const link = document.createElement('a');
    link.href = URL.createObjectURL(dataBlob);
    link.download = `${(currentOutlineData.title || 'ppt_outline')}_${new Date().toISOString().split('T')[0]}.json`;

    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    console.log('å¤§çº²JSONæ–‡ä»¶å·²å¯¼å‡º');
}


// å¤§çº²è§†å›¾æ¨¡å¼åˆ‡æ¢ï¼ˆç®€æ´è§†å›¾ vs è¯¦ç»†è§†å›¾ï¼‰
function toggleOutlineViewMode() {
    isDetailView = !isDetailView;
    const toggleText = document.getElementById('viewToggleText');

    if (toggleText) {
        toggleText.textContent = isDetailView ? 'ç®€æ´è§†å›¾' : 'è¯¦ç»†è§†å›¾';
    }

    // é‡æ–°æ¸²æŸ“å¤§çº²è§†å›¾
    renderOutlineView();
}



// æ›´æ–°JSONç¼–è¾‘å™¨å†…å®¹
function updateJsonEditor(jsonString) {
    const contentDiv = document.getElementById('outline-content-display');
    if (contentDiv) {
        // å°è¯•æ ¼å¼åŒ–JSON
        let formattedContent;
        let parsedOutline = null;
        try {
            parsedOutline = JSON.parse(jsonString);
            formattedContent = JSON.stringify(parsedOutline, null, 2);
        } catch (e) {
            formattedContent = jsonString;
        }

        // åˆ›å»ºpreå…ƒç´ æ¥æ­£ç¡®æ˜¾ç¤ºJSON
        const preElement = document.createElement('pre');
        preElement.style.cssText = 'margin: 0; font-family: "Consolas", "Monaco", "Courier New", monospace; font-size: 13px; white-space: pre-wrap; word-wrap: break-word;';
        preElement.textContent = formattedContent;
        contentDiv.innerHTML = '';
        contentDiv.appendChild(preElement);

        // å¦‚æœå½“å‰æ˜¯å¤§çº²è§†å›¾ï¼Œç«‹å³æ›´æ–°å¤§çº²æ˜¾ç¤º
        if (parsedOutline && currentViewNew === 'outline') {
            setTimeout(() => {
                renderOutlineViewNewWithData(parsedOutline);
            }, 100);
        }
    }
}

// ä¿å­˜å¤§çº²åˆ°æœåŠ¡å™¨
async function saveOutlineToServer(jsonString) {
    try {
        const response = await fetch(`/projects/${currentProjectId}/update-outline`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                outline_content: jsonString
            })
        });

        if (!response.ok) {
            throw new Error('ä¿å­˜åˆ°æœåŠ¡å™¨å¤±è´¥');
        }

        console.log('å¤§çº²å·²ä¿å­˜åˆ°æœåŠ¡å™¨');
    } catch (error) {
        console.error('ä¿å­˜åˆ°æœåŠ¡å™¨å¤±è´¥:', error);
        throw error;
    }
}

// ========== äº‹ä»¶ç›‘å¬å™¨ ==========

// é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
document.addEventListener('DOMContentLoaded', function() {
    // éšè—å³é”®èœå•å½“ç‚¹å‡»å…¶ä»–åœ°æ–¹æ—¶
    document.addEventListener('click', function(event) {
        if (!event.target.closest('#mindmap-context-menu')) {
            hideContextMenu();
        }
    });

    // é”®ç›˜äº‹ä»¶å¤„ç†
    document.addEventListener('keydown', function(event) {
        // ESCé”®å–æ¶ˆç¼–è¾‘
        if (event.key === 'Escape') {
            if (document.getElementById('node-edit-modal').style.display === 'block') {
                cancelNodeEdit();
            }
            hideContextMenu();
            clearNodeSelection();
        }

        // Enteré”®ä¿å­˜ç¼–è¾‘
        if (event.key === 'Enter' && document.getElementById('node-edit-modal').style.display === 'block') {
            saveNodeEdit();
        }
    });

    // é¡µé¢åŠ è½½æ—¶æ£€æŸ¥æ˜¯å¦æœ‰ç°æœ‰çš„å¤§çº²æ•°æ®
    setTimeout(function() {
        const outlineDisplay = document.getElementById('outline-content-display');
        if (outlineDisplay) {
            const content = outlineDisplay.textContent || outlineDisplay.innerText || '';
            if (content.trim()) {
                try {
                    const parsedOutline = JSON.parse(content);
                    if (parsedOutline && parsedOutline.slides) {
                        // æ¸²æŸ“å¤§çº²é¢„è§ˆ
                        renderOutlinePreview(parsedOutline);

                        // å¦‚æœå½“å‰æ˜¯å¤§çº²è§†å›¾ï¼Œæ¸²æŸ“å¤§çº²å†…å®¹
                        if (currentView === 'outline') {
                            renderOutlineView();
                        }

                        // å¦‚æœå½“å‰æ˜¯æ–°çš„å¤§çº²è§†å›¾ï¼Œæ¸²æŸ“æ–°çš„å¤§çº²å†…å®¹
                        if (currentViewNew === 'outline') {
                            renderOutlineViewNew();
                        }
                    }
                } catch (e) {
                    console.log('ç°æœ‰å†…å®¹ä¸æ˜¯æœ‰æ•ˆçš„JSONæ ¼å¼');
                }
            }
        }
    }, 500);
});

// ========== å…¨å±åŠŸèƒ½ ==========

let isFullscreen = false;
let originalMindmapData = null;

// åˆ‡æ¢å…¨å±æ¨¡å¼
function toggleMindmapFullscreen() {
    const modal = document.getElementById('mindmap-fullscreen-modal');
    const fullscreenCanvas = document.getElementById('mindmap-fullscreen-canvas');
    const fullscreenBtn = document.querySelector('button[onclick="toggleMindmapFullscreen()"]');

    if (!modal) {
        console.error('å…¨å±æ¨¡æ€æ¡†ä¸å­˜åœ¨');
        return;
    }

    if (!isFullscreen) {
        // è¿›å…¥å…¨å±
        isFullscreen = true;
        modal.style.display = 'block';

        // æ›´æ–°æŒ‰é’®å›¾æ ‡
        if (fullscreenBtn) {
            fullscreenBtn.innerHTML = '<i class="fas fa-compress"></i> é€€å‡ºå…¨å±';
        }

        // å¤åˆ¶å½“å‰æ€ç»´å¯¼å›¾æ•°æ®åˆ°å…¨å±ç”»å¸ƒ
        if (mindmapData) {
            originalMindmapData = JSON.parse(JSON.stringify(mindmapData)); // æ·±æ‹·è´
            setTimeout(() => {
                renderMindmapInContainer(mindmapData, 'mindmap-fullscreen-canvas');
            }, 100);
        } else {
            // å¦‚æœæ²¡æœ‰æ•°æ®ï¼Œæ˜¾ç¤ºç©ºçŠ¶æ€
            fullscreenCanvas.innerHTML = `
                <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #7f8c8d;">
                    <i class="fas fa-project-diagram fa-4x" style="margin-bottom: 30px; opacity: 0.3;"></i>
                    <h3 style="color: #95a5a6; margin-bottom: 20px;">å…¨å±æ€ç»´å¯¼å›¾ç¼–è¾‘å™¨</h3>
                    <p style="margin-bottom: 30px; font-size: 16px;">åœ¨è¿™é‡Œæ‚¨å¯ä»¥æ›´ä¸“æ³¨åœ°ç¼–è¾‘æ€ç»´å¯¼å›¾</p>
                    <button onclick="loadSampleData(); setTimeout(() => renderMindmapInContainer(mindmapData, 'mindmap-fullscreen-canvas'), 100);" class="btn btn-primary">
                        <i class="fas fa-download"></i> åŠ è½½ç¤ºä¾‹æ•°æ®
                    </button>
                </div>
            `;
        }

        // ç¦ç”¨é¡µé¢æ»šåŠ¨
        document.body.style.overflow = 'hidden';

    } else {
        // é€€å‡ºå…¨å±
        isFullscreen = false;
        modal.style.display = 'none';

        // æ›´æ–°æŒ‰é’®å›¾æ ‡
        if (fullscreenBtn) {
            fullscreenBtn.innerHTML = '<i class="fas fa-expand"></i> å…¨å±';
        }

        // æ¢å¤é¡µé¢æ»šåŠ¨
        document.body.style.overflow = 'auto';

        // å°†å…¨å±ä¸­çš„ä¿®æ”¹åŒæ­¥å›åŸå§‹ç”»å¸ƒ
        if (mindmapData && originalMindmapData) {
            // æ£€æŸ¥æ˜¯å¦æœ‰ä¿®æ”¹
            const hasChanges = JSON.stringify(mindmapData) !== JSON.stringify(originalMindmapData);
            if (hasChanges) {
                // é‡æ–°æ¸²æŸ“åŸå§‹ç”»å¸ƒ
                renderMindmap(mindmapData);
                console.log('å…¨å±ä¿®æ”¹å·²åŒæ­¥åˆ°åŸå§‹ç”»å¸ƒ');
            }
        }
    }
}

// åœ¨æŒ‡å®šå®¹å™¨ä¸­æ¸²æŸ“æ€ç»´å¯¼å›¾
function renderMindmapInContainer(data, containerId) {
    const container = document.getElementById(containerId);
    if (!container || !data) {
        console.error('å®¹å™¨æˆ–æ•°æ®ä¸å­˜åœ¨:', containerId, data);
        return;
    }

    // æ¸…ç©ºå®¹å™¨
    container.innerHTML = '';

    // åˆ›å»ºSVG
    const svg = d3.select(`#${containerId}`)
        .append('svg')
        .attr('width', '100%')
        .attr('height', '100%')
        .style('background', '#fafafa');

    // åˆ›å»ºç¼©æ”¾ç»„
    const g = svg.append('g');

    // è®¾ç½®ç¼©æ”¾è¡Œä¸º
    const zoom = d3.zoom()
        .scaleExtent([0.1, 3])
        .on('zoom', function(event) {
            g.attr('transform', event.transform);
        });

    svg.call(zoom);

    // åˆ›å»ºæ ‘å¸ƒå±€
    const tree = d3.tree()
        .size([container.clientHeight - 100, container.clientWidth - 200]);

    // è½¬æ¢æ•°æ®ä¸ºå±‚æ¬¡ç»“æ„
    const root = d3.hierarchy(data);
    tree(root);

    // ç»˜åˆ¶è¿æ¥çº¿
    g.selectAll('.link')
        .data(root.links())
        .enter().append('path')
        .attr('class', 'link')
        .attr('d', d3.linkHorizontal()
            .x(d => d.y + 100)
            .y(d => d.x + 50))
        .style('fill', 'none')
        .style('stroke', '#3498db')
        .style('stroke-width', 2);

    // ç»˜åˆ¶èŠ‚ç‚¹
    const node = g.selectAll('.node')
        .data(root.descendants())
        .enter().append('g')
        .attr('class', 'node')
        .attr('transform', d => `translate(${d.y + 100},${d.x + 50})`)
        .style('cursor', 'pointer');

    // æ·»åŠ èŠ‚ç‚¹åœ†åœˆ
    node.append('circle')
        .attr('r', d => d.depth === 0 ? 12 : 8)
        .style('fill', d => d.depth === 0 ? '#e74c3c' : '#3498db')
        .style('stroke', 'white')
        .style('stroke-width', 2);

    // æ·»åŠ èŠ‚ç‚¹æ–‡æœ¬
    node.append('text')
        .attr('dy', '.35em')
        .attr('x', d => d.children ? -15 : 15)
        .style('text-anchor', d => d.children ? 'end' : 'start')
        .style('font-size', '14px')
        .style('font-family', 'Microsoft YaHei, Arial, sans-serif')
        .style('fill', '#2c3e50')
        .text(d => d.data.name);

    // æ·»åŠ èŠ‚ç‚¹äº¤äº’
    node.on('dblclick', function(event, d) {
        editNodeInFullscreen(d);
    });

    node.on('contextmenu', function(event, d) {
        event.preventDefault();
        showContextMenuInFullscreen(event, d);
    });

    // å±…ä¸­æ˜¾ç¤º
    const bounds = g.node().getBBox();
    const centerX = container.clientWidth / 2 - bounds.width / 2;
    const centerY = container.clientHeight / 2 - bounds.height / 2;

    svg.call(zoom.transform, d3.zoomIdentity.translate(centerX, centerY));

    console.log('æ€ç»´å¯¼å›¾å·²åœ¨å®¹å™¨ä¸­æ¸²æŸ“:', containerId);
}

// New view switching functions for the new outline section
let currentViewNew = 'json'; // Default to JSON view for better compatibility
let currentEditInput = null; // Track current editing input to prevent duplicates

function switchOutlineViewNew(view) {
    console.log('Switching to view:', view);

    const jsonViewBtn = document.getElementById('json-view-btn-new');
    const outlineViewBtn = document.getElementById('outline-view-btn-new');
    const jsonView = document.getElementById('outline-content-display');
    const outlineView = document.getElementById('outline-view-new');
    const actionsDiv = document.getElementById('outline-actions');

    if (!jsonViewBtn || !outlineViewBtn || !jsonView || !outlineView) {
        console.error('View elements not found');
        return;
    }

    currentViewNew = view;

    if (view === 'json') {
        // Show JSON view
        jsonView.style.display = 'block';
        outlineView.style.display = 'none';

        // Show action buttons in JSON view
        if (actionsDiv) {
            actionsDiv.style.display = 'block';
        }

        // Update button styles
        jsonViewBtn.style.background = '#3498db';
        jsonViewBtn.style.color = 'white';
        outlineViewBtn.style.background = 'transparent';
        outlineViewBtn.style.color = '#6c757d';
    } else if (view === 'outline') {
        // Show outline view
        jsonView.style.display = 'none';
        outlineView.style.display = 'block';

        // Hide action buttons in outline view
        if (actionsDiv) {
            actionsDiv.style.display = 'none';
        }

        // Update button styles
        outlineViewBtn.style.background = '#3498db';
        outlineViewBtn.style.color = 'white';
        jsonViewBtn.style.background = 'transparent';
        jsonViewBtn.style.color = '#6c757d';

        // Generate outline view if content exists
        renderOutlineViewNew();
    }
}

// æ¸²æŸ“æ–°çš„å¤§çº²è§†å›¾
function renderOutlineViewNew() {
    let outlineContent = getOutlineContentNew();
    const outlineContainer = document.getElementById('outline-content-new');
    const loadingDiv = document.getElementById('outline-loading-new');
    const errorDiv = document.getElementById('outline-error-new');
    const emptyDiv = document.getElementById('outline-empty-new');

    if (!outlineContainer) {
        console.error('Outline container not found');
        return;
    }

    // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
    if (loadingDiv) loadingDiv.style.display = 'block';
    if (errorDiv) errorDiv.style.display = 'none';
    if (emptyDiv) emptyDiv.style.display = 'none';

    try {
        if (!outlineContent) {
            // æ²¡æœ‰å†…å®¹ï¼Œæ˜¾ç¤ºç©ºçŠ¶æ€
            if (loadingDiv) loadingDiv.style.display = 'none';
            if (emptyDiv) emptyDiv.style.display = 'block';
            return;
        }

        // é¢å¤–çš„å†…å®¹æ¸…ç†ï¼Œç¡®ä¿JSONæ ¼å¼æ­£ç¡®
        outlineContent = outlineContent.trim();

        // å¦‚æœå†…å®¹ä¸æ˜¯ä»¥{å¼€å¤´ï¼Œå°è¯•æŸ¥æ‰¾JSONå¼€å§‹ä½ç½®
        if (!outlineContent.startsWith('{')) {
            const jsonStart = outlineContent.indexOf('{');
            if (jsonStart > 0) {
                outlineContent = outlineContent.substring(jsonStart);
                console.log('ä»ä½ç½®', jsonStart, 'å¼€å§‹æå–JSONå†…å®¹');
            }
        }

        // å¦‚æœå†…å®¹ä¸æ˜¯ä»¥}ç»“å°¾ï¼Œå°è¯•æŸ¥æ‰¾JSONç»“æŸä½ç½®
        if (!outlineContent.endsWith('}')) {
            const jsonEnd = outlineContent.lastIndexOf('}');
            if (jsonEnd > 0) {
                outlineContent = outlineContent.substring(0, jsonEnd + 1);
                console.log('æˆªå–åˆ°ä½ç½®', jsonEnd + 1, 'çš„JSONå†…å®¹');
            }
        }

        let parsedOutline;
        try {
            parsedOutline = JSON.parse(outlineContent);
        } catch (parseError) {
            console.error('JSONè§£æå¤±è´¥:', parseError);
            if (loadingDiv) loadingDiv.style.display = 'none';
            if (errorDiv) errorDiv.style.display = 'block';
            return;
        }

        // ä½¿ç”¨è§£æåçš„æ•°æ®æ¸²æŸ“
        renderOutlineViewNewWithData(parsedOutline);

    } catch (error) {
        console.error('æ¸²æŸ“å¤§çº²è§†å›¾æ—¶å‡ºé”™:', error);
        if (loadingDiv) loadingDiv.style.display = 'none';
        if (errorDiv) errorDiv.style.display = 'block';
    }
}

// ä½¿ç”¨æŒ‡å®šæ•°æ®æ¸²æŸ“æ–°çš„å¤§çº²è§†å›¾
function renderOutlineViewNewWithData(parsedOutline) {
    const outlineContainer = document.getElementById('outline-content-new');
    const loadingDiv = document.getElementById('outline-loading-new');
    const errorDiv = document.getElementById('outline-error-new');
    const emptyDiv = document.getElementById('outline-empty-new');

    if (!outlineContainer) {
        console.error('Outline container not found');
        return;
    }

    try {
        if (!parsedOutline || !parsedOutline.slides) {
            // æ²¡æœ‰æœ‰æ•ˆæ•°æ®ï¼Œæ˜¾ç¤ºç©ºçŠ¶æ€
            if (loadingDiv) loadingDiv.style.display = 'none';
            if (errorDiv) errorDiv.style.display = 'none';
            if (emptyDiv) emptyDiv.style.display = 'block';
            return;
        }

        if (!parsedOutline.slides || parsedOutline.slides.length === 0) {
            // æ²¡æœ‰slidesæ•°æ®ï¼Œæ˜¾ç¤ºç©ºçŠ¶æ€
            if (loadingDiv) loadingDiv.style.display = 'none';
            if (emptyDiv) emptyDiv.style.display = 'block';
            return;
        }

        // æ¸²æŸ“å¤§çº²å†…å®¹
        renderOutlineContentNew(parsedOutline, outlineContainer);

        // éšè—åŠ è½½çŠ¶æ€
        if (loadingDiv) loadingDiv.style.display = 'none';

    } catch (error) {
        console.error('Error rendering outline view with data:', error);
        if (loadingDiv) loadingDiv.style.display = 'none';
        if (errorDiv) {
            errorDiv.style.display = 'block';
            const errorP = errorDiv.querySelector('p');
            if (errorP) {
                errorP.textContent = 'å¤§çº²æ¸²æŸ“å¤±è´¥ï¼š' + error.message;
            }
        }
    }
}

// å¤§çº²è§†å›¾æ¨¡å¼åˆ‡æ¢ï¼ˆç®€æ´è§†å›¾ vs è¯¦ç»†è§†å›¾ï¼‰
let isDetailViewNew = false;

function toggleOutlineViewModeNew() {
    isDetailViewNew = !isDetailViewNew;
    const toggleText = document.getElementById('viewToggleTextNew');

    if (toggleText) {
        toggleText.textContent = isDetailViewNew ? 'ç®€æ´è§†å›¾' : 'è¯¦ç»†è§†å›¾';
    }

    // é‡æ–°æ¸²æŸ“å¤§çº²è§†å›¾
    renderOutlineViewNew();
}

// æ¸²æŸ“å¤§çº²å†…å®¹
function renderOutlineContentNew(outline, container) {
    if (!outline || !outline.slides || !container) {
        return;
    }

    // æ¸…ç©ºå®¹å™¨
    container.innerHTML = '';

    // åˆ›å»ºæ ‡é¢˜åŒºåŸŸ
    const titleSection = document.createElement('div');
    titleSection.style.cssText = 'text-align: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid #ecf0f1;';
    titleSection.innerHTML = `
        <h4 style="color: #3498db; margin-bottom: 10px;">${outline.title || 'æœªå‘½åå¤§çº²'}</h4>
        <p style="color: #7f8c8d; margin: 0;">
            æ€»å…± ${outline.slides.length} é¡µå¹»ç¯ç‰‡ |
            åœºæ™¯: ${outline.metadata?.scenario || 'æœªæŒ‡å®š'} |
            è¯­è¨€: ${outline.metadata?.language || 'zh'}
        </p>
    `;
    container.appendChild(titleSection);

    // åˆ›å»ºå¤§çº²å†…å®¹åŒºåŸŸ
    const contentSection = document.createElement('div');
    contentSection.style.cssText = 'background: #f8f9fa; border-radius: 10px; padding: 20px;';

    if (isDetailViewNew) {
        // è¯¦ç»†è§†å›¾
        renderDetailedOutlineView(outline.slides, contentSection);
    } else {
        // ç®€æ´è§†å›¾
        renderCompactOutlineView(outline.slides, contentSection);
    }

    container.appendChild(contentSection);
}

// æ¸²æŸ“ç®€æ´è§†å›¾
function renderCompactOutlineView(slides, container) {
    const gridContainer = document.createElement('div');
    gridContainer.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px;';

    slides.forEach((slide, index) => {
        const slideCard = document.createElement('div');
        slideCard.style.cssText = `
            padding: 15px; background: white; border-radius: 8px;
            border-left: 4px solid #3498db; transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); position: relative; cursor: pointer;
        `;

        // æ·»åŠ æ‚¬åœæ•ˆæœ
        slideCard.addEventListener('mouseenter', function() {
            this.style.transform = 'translateY(-2px)';
            this.style.boxShadow = '0 4px 8px rgba(0,0,0,0.15)';
        });
        slideCard.addEventListener('mouseleave', function() {
            this.style.transform = 'translateY(0)';
            this.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
        });

        // æ“ä½œæŒ‰é’®
        const actionButtons = document.createElement('div');
        actionButtons.style.cssText = 'position: absolute; top: 10px; right: 10px; display: flex; gap: 5px;';
        actionButtons.innerHTML = `
            <button onclick="editSingleSlideNew(${index})" class="btn btn-primary" style="font-size: 0.7em; padding: 4px 8px; border-radius: 4px;" title="ç¼–è¾‘æ­¤é¡µ">
                <i class="fas fa-edit"></i>
            </button>
            <button onclick="viewSlideDetailNew(${index})" class="btn btn-info" style="font-size: 0.7em; padding: 4px 8px; border-radius: 4px;" title="æŸ¥çœ‹è¯¦æƒ…">
                <i class="fas fa-eye"></i>
            </button>
        `;

        // å†…å®¹åŒºåŸŸ
        const contentArea = document.createElement('div');
        contentArea.style.cssText = 'margin-right: 60px;';
        contentArea.addEventListener('click', () => viewSlideDetailNew(index));

        const header = document.createElement('div');
        header.style.cssText = 'display: flex; align-items: center; margin-bottom: 8px;';
        header.innerHTML = `
            <span style="background: #3498db; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-size: 0.8em; font-weight: bold; margin-right: 10px;">
                ${slide.page_number || index + 1}
            </span>
            <strong style="color: #2c3e50; font-size: 0.9em;">${slide.title || 'æœªå‘½åå¹»ç¯ç‰‡'}</strong>
        `;

        const subtitle = document.createElement('div');
        if (slide.subtitle) {
            subtitle.innerHTML = `<p style="color: #7f8c8d; font-size: 0.8em; margin: 5px 0; font-style: italic;">${slide.subtitle}</p>`;
        }

        const content = document.createElement('div');
        content.style.cssText = 'color: #666; font-size: 0.8em; line-height: 1.4;';

        if (slide.content_points && slide.content_points.length > 0) {
            const firstPoint = slide.content_points[0];
            const truncatedPoint = firstPoint.length > 80 ? firstPoint.substring(0, 80) + '...' : firstPoint;
            content.innerHTML = truncatedPoint;

            if (slide.content_points.length > 1) {
                content.innerHTML += `<br><span style="color: #95a5a6;">+${slide.content_points.length - 1} ä¸ªè¦ç‚¹</span>`;
            }
        } else if (slide.content) {
            const truncatedContent = slide.content.length > 80 ? slide.content.substring(0, 80) + '...' : slide.content;
            content.innerHTML = truncatedContent;
        } else {
            content.innerHTML = '<span style="color: #95a5a6;">æš‚æ— å†…å®¹</span>';
        }

        contentArea.appendChild(header);
        contentArea.appendChild(subtitle);
        contentArea.appendChild(content);

        slideCard.appendChild(actionButtons);
        slideCard.appendChild(contentArea);
        gridContainer.appendChild(slideCard);
    });

    container.appendChild(gridContainer);
}

// æ¸²æŸ“è¯¦ç»†è§†å›¾
function renderDetailedOutlineView(slides, container) {
    const detailContainer = document.createElement('div');
    detailContainer.style.cssText = 'max-height: 400px; overflow-y: auto;';

    slides.forEach((slide, index) => {
        const slideDetail = document.createElement('div');
        slideDetail.style.cssText = `
            padding: 20px; margin-bottom: 15px; background: white;
            border-radius: 10px; border-left: 4px solid #3498db; position: relative;
        `;

        const header = document.createElement('div');
        header.style.cssText = 'display: flex; align-items: center; margin-bottom: 15px;';
        header.innerHTML = `
            <span style="background: #3498db; color: white; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-weight: bold; margin-right: 15px;">
                ${slide.page_number || index + 1}
            </span>
            <div style="flex: 1;">
                <strong style="color: #2c3e50; font-size: 1.1em;">${slide.title || 'æœªå‘½åå¹»ç¯ç‰‡'}</strong>
                ${slide.subtitle ? `<br><em style="color: #7f8c8d; font-size: 0.9em;">${slide.subtitle}</em>` : ''}
            </div>
            <button onclick="editSingleSlideNew(${index})" class="btn btn-primary" style="font-size: 0.8em; padding: 6px 12px;" title="ç¼–è¾‘æ­¤é¡µ">
                <i class="fas fa-edit"></i> ç¼–è¾‘
            </button>
        `;

        const contentSection = document.createElement('div');

        if (slide.content_points && slide.content_points.length > 0) {
            const pointsSection = document.createElement('div');
            pointsSection.style.cssText = 'margin-top: 10px;';
            pointsSection.innerHTML = '<h5 style="color: #555; margin-bottom: 8px; font-size: 0.9em;">å†…å®¹è¦ç‚¹ï¼š</h5>';

            const pointsList = document.createElement('ul');
            pointsList.style.cssText = 'margin: 0; padding-left: 20px; color: #555; line-height: 1.6;';

            slide.content_points.forEach(point => {
                const listItem = document.createElement('li');
                listItem.style.cssText = 'margin-bottom: 5px;';
                listItem.textContent = point;
                pointsList.appendChild(listItem);
            });

            pointsSection.appendChild(pointsList);
            contentSection.appendChild(pointsSection);
        } else if (slide.content) {
            const contentDiv = document.createElement('div');
            contentDiv.style.cssText = 'margin-top: 10px;';
            contentDiv.innerHTML = `
                <h5 style="color: #555; margin-bottom: 8px; font-size: 0.9em;">å†…å®¹ï¼š</h5>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 6px; color: #555; line-height: 1.6; white-space: pre-wrap;">${slide.content}</div>
            `;
            contentSection.appendChild(contentDiv);
        }

        if (slide.slide_type) {
            const typeTag = document.createElement('div');
            typeTag.style.cssText = 'margin-top: 10px;';
            typeTag.innerHTML = `
                <span style="background: #e8f4fd; color: #3498db; padding: 4px 8px; border-radius: 4px; font-size: 0.8em;">
                    ç±»å‹: ${slide.slide_type}
                </span>
            `;
            contentSection.appendChild(typeTag);
        }

        slideDetail.appendChild(header);
        slideDetail.appendChild(contentSection);
        detailContainer.appendChild(slideDetail);
    });

    container.appendChild(detailContainer);
}

// æŸ¥çœ‹å¹»ç¯ç‰‡è¯¦æƒ…
function viewSlideDetailNew(slideIndex) {
    const outlineContent = getOutlineContent();
    if (!outlineContent) return;

    try {
        const parsedOutline = JSON.parse(outlineContent);
        const slide = parsedOutline.slides[slideIndex];

        if (!slide) return;

        // åˆ›å»ºæ¨¡æ€æ¡†æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); z-index: 1000; display: flex;
            align-items: center; justify-content: center; padding: 20px;
        `;

        const content = document.createElement('div');
        content.style.cssText = `
            background: white; border-radius: 15px; padding: 30px;
            max-width: 600px; max-height: 80vh; overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        `;

        let contentPoints = '';
        if (slide.content_points && slide.content_points.length > 0) {
            contentPoints = '<h5 style="color: #555; margin: 15px 0 8px 0;">å†…å®¹è¦ç‚¹ï¼š</h5><ul style="margin: 0; padding-left: 20px; color: #555; line-height: 1.6;">';
            slide.content_points.forEach(point => {
                contentPoints += `<li style="margin-bottom: 5px;">${point}</li>`;
            });
            contentPoints += '</ul>';
        } else if (slide.content) {
            contentPoints = `<h5 style="color: #555; margin: 15px 0 8px 0;">å†…å®¹ï¼š</h5><div style="background: #f8f9fa; padding: 15px; border-radius: 6px; color: #555; line-height: 1.6; white-space: pre-wrap;">${slide.content}</div>`;
        }

        content.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h3 style="color: #2c3e50; margin: 0;">ç¬¬${slide.page_number || slideIndex + 1}é¡µè¯¦æƒ…</h3>
                <button onclick="this.closest('.modal').remove()" style="background: #e74c3c; color: white; border: none; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; font-size: 16px;">Ã—</button>
            </div>
            <h4 style="color: #3498db; margin-bottom: 10px;">${slide.title || 'æœªå‘½åå¹»ç¯ç‰‡'}</h4>
            ${slide.subtitle ? `<p style="color: #7f8c8d; font-style: italic; margin-bottom: 15px;">${slide.subtitle}</p>` : ''}
            ${contentPoints}
            ${slide.slide_type ? `<div style="margin-top: 15px;"><span style="background: #e8f4fd; color: #3498db; padding: 6px 12px; border-radius: 6px; font-size: 0.9em;">ç±»å‹: ${slide.slide_type}</span></div>` : ''}
        `;

        modal.className = 'modal';
        modal.appendChild(content);
        document.body.appendChild(modal);

        // ç‚¹å‡»èƒŒæ™¯å…³é—­
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.remove();
            }
        });
    } catch (error) {
        console.error('Error viewing slide detail:', error);
        alert('æŸ¥çœ‹è¯¦æƒ…å¤±è´¥: ' + error.message);
    }
}

// ç¼–è¾‘å¤§çº²
function editOutlineNew() {
    const outlineContent = getOutlineContent();
    if (!outlineContent) {
        alert('å¤§çº²æ•°æ®ä¸å­˜åœ¨ï¼Œæ— æ³•ç¼–è¾‘');
        return;
    }

    // åˆ›å»ºç¼–è¾‘æ¨¡æ€æ¡†
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.5); z-index: 1000; display: flex;
        align-items: center; justify-content: center; padding: 20px;
    `;

    const content = document.createElement('div');
    content.style.cssText = `
        background: white; border-radius: 15px; padding: 30px;
        width: 90%; max-width: 800px; height: 80vh; display: flex;
        flex-direction: column; box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    `;

    content.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="color: #2c3e50; margin: 0;">ç¼–è¾‘PPTå¤§çº²</h3>
            <button onclick="this.closest('.modal').remove()" style="background: #e74c3c; color: white; border: none; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; font-size: 16px;">Ã—</button>
        </div>
        <div style="flex: 1; display: flex; flex-direction: column;">
            <textarea id="outlineEditorNew" style="flex: 1; border: 2px solid #ecf0f1; border-radius: 8px; padding: 15px; font-family: 'Courier New', monospace; font-size: 14px; line-height: 1.5; resize: none;" placeholder="ç¼–è¾‘å¤§çº²JSON...">${outlineContent}</textarea>
            <div style="display: flex; gap: 8px; margin-top: 15px; justify-content: flex-end;">
                <button onclick="this.closest('.modal').remove()" class="btn btn-sm" style="background: #95a5a6; color: white;">å–æ¶ˆ</button>
                <button onclick="saveOutlineChangesNew()" class="btn btn-sm btn-primary">ä¿å­˜ä¿®æ”¹</button>
            </div>
        </div>
    `;

    modal.className = 'modal';
    modal.appendChild(content);
    document.body.appendChild(modal);
}

// ä¿å­˜å¤§çº²ä¿®æ”¹
async function saveOutlineChangesNew() {
    const editor = document.getElementById('outlineEditorNew');
    if (!editor) return;

    try {
        const newOutline = JSON.parse(editor.value);

        const response = await fetch(`/projects/${currentProjectId}/update-outline`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ outline_content: editor.value })
        });

        if (response.ok) {
            alert('å¤§çº²ä¿®æ”¹æˆåŠŸï¼');
            // å…³é—­æ¨¡æ€æ¡†
            const modal = editor.closest('.modal');
            if (modal) modal.remove();

            // æ›´æ–°JSONæ˜¾ç¤ºåŒºåŸŸ
            const outlineDisplay = document.getElementById('outline-content-display');
            if (outlineDisplay) {
                const preElement = document.createElement('pre');
                preElement.style.cssText = 'margin: 0; font-family: "Consolas", "Monaco", "Courier New", monospace; font-size: 13px; white-space: pre-wrap; word-wrap: break-word;';
                preElement.textContent = editor.value;
                outlineDisplay.innerHTML = '';
                outlineDisplay.appendChild(preElement);
            }

            // ç«‹å³é‡æ–°æ¸²æŸ“å¤§çº²è§†å›¾ï¼Œä½¿ç”¨æœ€æ–°æ•°æ®
            setTimeout(() => {
                renderOutlineViewNewWithData(newOutline);
            }, 100); // å‡å°‘å»¶è¿Ÿ
        } else {
            const error = await response.json();
            alert('ä¿å­˜å¤±è´¥: ' + (error.detail || 'æœªçŸ¥é”™è¯¯'));
        }
    } catch (error) {
        if (error instanceof SyntaxError) {
            alert('JSONæ ¼å¼é”™è¯¯ï¼Œè¯·æ£€æŸ¥è¯­æ³•ï¼');
        } else {
            console.error('Error saving outline:', error);
            alert('ä¿å­˜å¤±è´¥: ' + error.message);
        }
    }
}

// å¯¼å‡ºå¤§çº²ä¸ºJSONæ–‡ä»¶
function exportOutlineJSONNew() {
    const outlineContent = getOutlineContent();
    if (!outlineContent) {
        alert('å¤§çº²æ•°æ®ä¸å­˜åœ¨ï¼Œæ— æ³•å¯¼å‡º');
        return;
    }

    try {
        const parsedOutline = JSON.parse(outlineContent);
        const dataStr = JSON.stringify(parsedOutline, null, 2);
        const dataBlob = new Blob([dataStr], {type: 'application/json'});

        const link = document.createElement('a');
        link.href = URL.createObjectURL(dataBlob);
        link.download = `${(parsedOutline.title || 'ppt_outline')}_${new Date().toISOString().split('T')[0]}.json`;

        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        // æ˜¾ç¤ºæˆåŠŸæç¤º
        const toast = document.createElement('div');
        toast.style.cssText = `
            position: fixed; top: 20px; right: 20px; background: #27ae60;
            color: white; padding: 15px 20px; border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1001;
            font-size: 14px; font-weight: bold;
        `;
        toast.textContent = 'âœ… å¤§çº²JSONæ–‡ä»¶å·²å¯¼å‡º';
        document.body.appendChild(toast);

        setTimeout(() => {
            toast.remove();
        }, 3000);
    } catch (error) {
        console.error('Error exporting outline:', error);
        alert('å¯¼å‡ºå¤±è´¥: ' + error.message);
    }
}

// ç¼–è¾‘å•é¡µå¹»ç¯ç‰‡
function editSingleSlideNew(slideIndex) {
    const outlineContent = getOutlineContentNew();
    if (!outlineContent) {
        alert('å¤§çº²æ•°æ®ä¸å­˜åœ¨ï¼Œæ— æ³•ç¼–è¾‘');
        return;
    }

    try {
        const parsedOutline = JSON.parse(outlineContent);
        const slide = parsedOutline.slides[slideIndex];

        if (!slide) {
            alert('å¹»ç¯ç‰‡ä¸å­˜åœ¨');
            return;
        }

        // åˆ›å»ºå•é¡µç¼–è¾‘æ¨¡æ€æ¡†
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); z-index: 1000; display: flex;
            align-items: center; justify-content: center; padding: 20px;
        `;

        const content = document.createElement('div');
        content.style.cssText = `
            background: white; border-radius: 15px; padding: 30px;
            width: 90%; max-width: 700px; max-height: 85vh; overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        `;

        // æ„å»ºå†…å®¹è¦ç‚¹çš„ç¼–è¾‘ç•Œé¢ - ä½¿ç”¨å ä½ç¬¦ï¼Œç¨åç”¨JavaScriptåˆ›å»º
        let contentPointsHtml = '';
        if (slide.content_points && slide.content_points.length > 0) {
            slide.content_points.forEach((point, index) => {
                contentPointsHtml += `
                    <div class="content-point-item" data-point-index="${index}" style="display: flex; align-items: center; margin-bottom: 10px;">
                        <input type="text" class="content-point-input" data-index="${index}"
                               value="${point.replace(/"/g, '&quot;')}"
                               style="flex: 1; padding: 8px 12px; border: 2px solid #ecf0f1; border-radius: 6px; font-size: 14px;">
                        <button class="remove-point-btn" data-remove-index="${index}"
                                style="background: #e74c3c; color: white; border: none; border-radius: 4px; padding: 6px 10px; margin-left: 8px; cursor: pointer;">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                `;
            });
        }

        content.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px;">
                <h3 style="color: #2c3e50; margin: 0;">ç¼–è¾‘ç¬¬${slide.page_number || slideIndex + 1}é¡µ</h3>
                <button onclick="this.closest('.modal').remove()"
                        style="background: #e74c3c; color: white; border: none; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; font-size: 16px;">Ã—</button>
            </div>

            <form id="singleSlideEditForm" style="display: flex; flex-direction: column; gap: 20px;">
                <!-- é¡µé¢æ ‡é¢˜ -->
                <div>
                    <label style="display: block; color: #2c3e50; font-weight: bold; margin-bottom: 8px;">é¡µé¢æ ‡é¢˜</label>
                    <input type="text" id="slideTitle" value="${(slide.title || '').replace(/"/g, '&quot;')}"
                           style="width: 100%; padding: 12px; border: 2px solid #ecf0f1; border-radius: 8px; font-size: 16px;">
                </div>

                <!-- é¡µé¢å‰¯æ ‡é¢˜ -->
                <div>
                    <label style="display: block; color: #2c3e50; font-weight: bold; margin-bottom: 8px;">å‰¯æ ‡é¢˜ï¼ˆå¯é€‰ï¼‰</label>
                    <input type="text" id="slideSubtitle" value="${(slide.subtitle || '').replace(/"/g, '&quot;')}"
                           style="width: 100%; padding: 12px; border: 2px solid #ecf0f1; border-radius: 8px; font-size: 14px;">
                </div>

                <!-- å¹»ç¯ç‰‡ç±»å‹ -->
                <div>
                    <label style="display: block; color: #2c3e50; font-weight: bold; margin-bottom: 8px;">å¹»ç¯ç‰‡ç±»å‹</label>
                    <select id="slideType" style="width: 100%; padding: 12px; border: 2px solid #ecf0f1; border-radius: 8px; font-size: 14px;">
                        <option value="title" ${slide.slide_type === 'title' ? 'selected' : ''}>æ ‡é¢˜é¡µ</option>
                        <option value="content" ${slide.slide_type === 'content' ? 'selected' : ''}>å†…å®¹é¡µ</option>
                        <option value="conclusion" ${slide.slide_type === 'conclusion' ? 'selected' : ''}>ç»“è®ºé¡µ</option>
                        <option value="thankyou" ${slide.slide_type === 'thankyou' ? 'selected' : ''}>æ„Ÿè°¢é¡µ</option>
                    </select>
                </div>

                <!-- å†…å®¹è¦ç‚¹ -->
                <div>
                    <label style="display: block; color: #2c3e50; font-weight: bold; margin-bottom: 8px;">å†…å®¹è¦ç‚¹</label>
                    <div id="contentPointsContainer" style="margin-bottom: 10px;">
                        ${contentPointsHtml}
                    </div>
                    <button type="button" onclick="addSingleContentPoint()"
                            style="background: #3498db; color: white; border: none; border-radius: 6px; padding: 8px 16px; cursor: pointer;">
                        <i class="fas fa-plus"></i> æ·»åŠ è¦ç‚¹
                    </button>
                </div>

                <!-- é¡µé¢æè¿° -->
                <div>
                    <label style="display: block; color: #2c3e50; font-weight: bold; margin-bottom: 8px;">é¡µé¢æè¿°ï¼ˆå¯é€‰ï¼‰</label>
                    <textarea id="slideDescription" rows="3"
                              style="width: 100%; padding: 12px; border: 2px solid #ecf0f1; border-radius: 8px; font-size: 14px; resize: vertical;">${slide.description || ''}</textarea>
                </div>

                <!-- æ“ä½œæŒ‰é’® -->
                <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                    <button type="button" onclick="this.closest('.modal').remove()"
                            class="btn" style="background: #95a5a6; color: white; padding: 12px 24px;">å–æ¶ˆ</button>
                    <button type="button" onclick="saveSingleSlideEdit(${slideIndex})"
                            class="btn btn-primary" style="padding: 12px 24px;">ä¿å­˜ä¿®æ”¹</button>
                </div>
            </form>
        `;

        modal.className = 'modal';
        modal.appendChild(content);
        document.body.appendChild(modal);

        // ä¸ºåˆ é™¤æŒ‰é’®æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
        const removeButtons = modal.querySelectorAll('.remove-point-btn');
        removeButtons.forEach(button => {
            button.addEventListener('click', function() {
                const index = parseInt(this.getAttribute('data-remove-index'));
                removeSingleContentPointByElement(this.parentElement);
            });
        });

        // ç‚¹å‡»èƒŒæ™¯å…³é—­
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.remove();
            }
        });

    } catch (error) {
        console.error('Error editing single slide:', error);
        alert('ç¼–è¾‘å¤±è´¥: ' + error.message);
    }
}

// æ·»åŠ å†…å®¹è¦ç‚¹
function addSingleContentPoint() {
    const container = document.getElementById('contentPointsContainer');
    if (!container) return;

    const currentPoints = container.querySelectorAll('.content-point-item');
    const newIndex = currentPoints.length;

    const pointDiv = document.createElement('div');
    pointDiv.className = 'content-point-item';
    pointDiv.style.cssText = 'display: flex; align-items: center; margin-bottom: 10px;';

    // åˆ›å»ºè¾“å…¥æ¡†
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'content-point-input';
    input.setAttribute('data-index', newIndex);
    input.placeholder = 'è¾“å…¥æ–°çš„å†…å®¹è¦ç‚¹...';
    input.style.cssText = 'flex: 1; padding: 8px 12px; border: 2px solid #ecf0f1; border-radius: 6px; font-size: 14px;';

    // åˆ›å»ºåˆ é™¤æŒ‰é’®
    const button = document.createElement('button');
    button.className = 'remove-point-btn';
    button.setAttribute('data-remove-index', newIndex);
    button.addEventListener('click', function() {
        removeSingleContentPointByElement(this.parentElement);
    });
    button.style.cssText = 'background: #e74c3c; color: white; border: none; border-radius: 4px; padding: 6px 10px; margin-left: 8px; cursor: pointer;';
    button.innerHTML = '<i class="fas fa-trash"></i>';

    pointDiv.appendChild(input);
    pointDiv.appendChild(button);

    container.appendChild(pointDiv);

    // èšç„¦åˆ°æ–°æ·»åŠ çš„è¾“å…¥æ¡†
    const newInput = pointDiv.querySelector('.content-point-input');
    if (newInput) {
        newInput.focus();
    }
}

// åˆ é™¤å†…å®¹è¦ç‚¹ï¼ˆé€šè¿‡ç´¢å¼•ï¼‰
function removeSingleContentPoint(index) {
    const container = document.getElementById('contentPointsContainer');
    if (!container) return;

    const pointItems = container.querySelectorAll('.content-point-item');
    if (pointItems[index]) {
        removeSingleContentPointByElement(pointItems[index]);
    }
}

// åˆ é™¤å†…å®¹è¦ç‚¹ï¼ˆé€šè¿‡å…ƒç´ ï¼‰
function removeSingleContentPointByElement(element) {
    if (!element) return;

    element.remove();

    // é‡æ–°ç¼–å·å‰©ä½™çš„è¦ç‚¹
    const container = document.getElementById('contentPointsContainer');
    if (!container) return;

    const remainingItems = container.querySelectorAll('.content-point-item');
    remainingItems.forEach((item, newIndex) => {
        const input = item.querySelector('.content-point-input');
        const button = item.querySelector('.remove-point-btn, button');
        if (input) input.setAttribute('data-index', newIndex);
        if (button) {
            if (button.classList.contains('remove-point-btn')) {
                button.setAttribute('data-remove-index', newIndex);
            } else {
                // é‡æ–°åˆ›å»ºæŒ‰é’®ä»¥æ›´æ–°äº‹ä»¶å¤„ç†
                const newButton = document.createElement('button');
                newButton.onclick = () => removeSingleContentPoint(newIndex);
                newButton.style.cssText = 'background: #e74c3c; color: white; border: none; border-radius: 4px; padding: 6px 10px; margin-left: 8px; cursor: pointer;';
                newButton.innerHTML = '<i class="fas fa-trash"></i>';
                button.parentNode.replaceChild(newButton, button);
            }
        }
    });
}

// ä¿å­˜å•é¡µç¼–è¾‘
async function saveSingleSlideEdit(slideIndex) {
    try {
        // è·å–è¡¨å•æ•°æ®
        const title = document.getElementById('slideTitle').value.trim();
        const subtitle = document.getElementById('slideSubtitle').value.trim();
        const slideType = document.getElementById('slideType').value;
        const description = document.getElementById('slideDescription').value.trim();

        // è·å–æ‰€æœ‰å†…å®¹è¦ç‚¹
        const contentPointInputs = document.querySelectorAll('.content-point-input');
        const contentPoints = Array.from(contentPointInputs)
            .map(input => input.value.trim())
            .filter(point => point.length > 0);

        if (!title) {
            alert('é¡µé¢æ ‡é¢˜ä¸èƒ½ä¸ºç©º');
            return;
        }

        if (contentPoints.length === 0) {
            alert('è‡³å°‘éœ€è¦ä¸€ä¸ªå†…å®¹è¦ç‚¹');
            return;
        }

        // è·å–å½“å‰å¤§çº²
        const outlineContent = getOutlineContentNew();
        const parsedOutline = JSON.parse(outlineContent);

        // æ›´æ–°æŒ‡å®šçš„å¹»ç¯ç‰‡
        const updatedSlide = {
            page_number: parsedOutline.slides[slideIndex].page_number || slideIndex + 1,
            title: title,
            content_points: contentPoints,
            slide_type: slideType,
            type: slideType // ä¿æŒå…¼å®¹æ€§
        };

        // æ·»åŠ å¯é€‰å­—æ®µ
        if (subtitle) {
            updatedSlide.subtitle = subtitle;
        }
        if (description) {
            updatedSlide.description = description;
        }

        // ä¿ç•™åŸæœ‰çš„å›¾è¡¨é…ç½®ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        if (parsedOutline.slides[slideIndex].chart_config) {
            updatedSlide.chart_config = parsedOutline.slides[slideIndex].chart_config;
        }

        // æ›´æ–°å¤§çº²
        parsedOutline.slides[slideIndex] = updatedSlide;

        // ä¿å­˜åˆ°æœåŠ¡å™¨
        const response = await fetch(`/projects/${currentProjectId}/update-outline`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                outline_content: JSON.stringify(parsedOutline, null, 2)
            })
        });

        if (response.ok) {
            // å…³é—­æ¨¡æ€æ¡†
            const modal = document.querySelector('.modal');
            if (modal) modal.remove();

            // æ›´æ–°JSONæ˜¾ç¤ºåŒºåŸŸ
            const outlineDisplay = document.getElementById('outline-content-display');
            if (outlineDisplay) {
                const formattedContent = JSON.stringify(parsedOutline, null, 2);
                const preElement = document.createElement('pre');
                preElement.style.cssText = 'margin: 0; font-family: "Consolas", "Monaco", "Courier New", monospace; font-size: 13px; white-space: pre-wrap; word-wrap: break-word;';
                preElement.textContent = formattedContent;
                outlineDisplay.innerHTML = '';
                outlineDisplay.appendChild(preElement);
            }

            // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed; top: 20px; right: 20px; background: #27ae60;
                color: white; padding: 15px 20px; border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1001;
                font-size: 14px; font-weight: bold;
            `;
            toast.textContent = `âœ… ç¬¬${slideIndex + 1}é¡µå·²æ›´æ–°`;
            document.body.appendChild(toast);

            setTimeout(() => {
                toast.remove();
            }, 3000);

            // ç«‹å³é‡æ–°æ¸²æŸ“å¤§çº²è§†å›¾ï¼Œä½¿ç”¨æœ€æ–°æ•°æ®
            setTimeout(() => {
                renderOutlineViewNewWithData(parsedOutline);
            }, 100);

        } else {
            const error = await response.json();
            alert('ä¿å­˜å¤±è´¥: ' + (error.detail || 'æœªçŸ¥é”™è¯¯'));
        }

    } catch (error) {
        console.error('Error saving single slide:', error);
        alert('ä¿å­˜å¤±è´¥: ' + error.message);
    }
}

// Generate mindmap for new outline section
function generateMindmapNew() {
    console.log('Generating mindmap for new outline section');

    const loadingDiv = document.getElementById('mindmap-loading-new');
    const errorDiv = document.getElementById('mindmap-error-new');
    const emptyDiv = document.getElementById('mindmap-empty-new');

    // Show loading
    if (loadingDiv) loadingDiv.style.display = 'block';
    if (errorDiv) errorDiv.style.display = 'none';
    if (emptyDiv) emptyDiv.style.display = 'none';

    try {
        // Get JSON outline content
        const outlineContent = getOutlineContentNew();
        if (!outlineContent) {
            // If no content, show empty state
            if (loadingDiv) loadingDiv.style.display = 'none';
            if (emptyDiv) emptyDiv.style.display = 'block';
            return;
        }

        // Parse JSON and convert to mindmap data
        const jsonData = JSON.parse(outlineContent);
        const mindmapData = convertJsonToMindmapNew(jsonData);

        // Render mindmap
        renderMindmapNew(mindmapData);

        // Hide loading
        if (loadingDiv) loadingDiv.style.display = 'none';

    } catch (error) {
        console.error('ç”Ÿæˆæ€ç»´å¯¼å›¾å¤±è´¥:', error);
        if (loadingDiv) loadingDiv.style.display = 'none';
        if (errorDiv) {
            errorDiv.style.display = 'block';
            errorDiv.querySelector('p').textContent = 'æ€ç»´å¯¼å›¾ç”Ÿæˆå¤±è´¥ï¼š' + error.message;
        }
        if (emptyDiv) emptyDiv.style.display = 'block';
    }
}

// Get outline content for new section
function getOutlineContentNew() {
    const contentDiv = document.getElementById('outline-content-display');
    if (!contentDiv) return null;

    // é¦–å…ˆå°è¯•ä»preå…ƒç´ ä¸­è·å–åŸå§‹æ–‡æœ¬å†…å®¹
    const preElement = contentDiv.querySelector('pre');
    if (preElement) {
        let content = preElement.textContent || preElement.innerText || '';

        // Remove placeholder text
        if (content.includes('æ­£åœ¨ç”Ÿæˆå¤§çº²') || content.includes('ç­‰å¾…å¤§çº²ç”Ÿæˆ')) {
            return null;
        }

        return content.trim();
    }

    // å¦‚æœæ²¡æœ‰preå…ƒç´ ï¼Œå°è¯•ä»æ•´ä¸ªdivè·å–å†…å®¹
    let content = contentDiv.textContent || contentDiv.innerText || '';

    // å¤„ç†HTMLå®ä½“å’Œæ ¼å¼é—®é¢˜
    content = content.replace(/&nbsp;/g, ' ')
                    .replace(/&lt;/g, '<')
                    .replace(/&gt;/g, '>')
                    .replace(/&amp;/g, '&')
                    .replace(/&quot;/g, '"')
                    .replace(/&#39;/g, "'")
                    .replace(/<br\s*\/?>/gi, '\n')
                    .replace(/\s+/g, ' ')
                    .trim();

    // Remove placeholder text
    if (content.includes('æ­£åœ¨ç”Ÿæˆå¤§çº²') || content.includes('ç­‰å¾…å¤§çº²ç”Ÿæˆ')) {
        return null;
    }

    return content;
}

// è°ƒè¯•å¤§çº²å†…å®¹çš„å‡½æ•°
function debugOutlineContent() {
    const outlineContent = getOutlineContentNew();

    console.log('=== å¤§çº²å†…å®¹è°ƒè¯•ä¿¡æ¯ ===');
    console.log('åŸå§‹å†…å®¹é•¿åº¦ï¼š', outlineContent ? outlineContent.length : 0);
    console.log('åŸå§‹å†…å®¹ï¼ˆå‰500å­—ç¬¦ï¼‰ï¼š', outlineContent ? outlineContent.substring(0, 500) : 'null');
    console.log('åŸå§‹å†…å®¹ï¼ˆå100å­—ç¬¦ï¼‰ï¼š', outlineContent ? outlineContent.substring(Math.max(0, outlineContent.length - 100)) : 'null');

    // æ£€æŸ¥å¸¸è§çš„JSONæ ¼å¼é—®é¢˜
    if (outlineContent) {
        console.log('é¦–å­—ç¬¦ï¼š', outlineContent.charAt(0), '(ASCII:', outlineContent.charCodeAt(0), ')');
        console.log('æœ«å­—ç¬¦ï¼š', outlineContent.charAt(outlineContent.length - 1), '(ASCII:', outlineContent.charCodeAt(outlineContent.length - 1), ')');

        // æ£€æŸ¥æ˜¯å¦åŒ…å«HTMLå®ä½“
        if (outlineContent.includes('&nbsp;')) {
            console.log('âš ï¸ å‘ç°HTMLå®ä½“ &nbsp;');
        }
        if (outlineContent.includes('<br>')) {
            console.log('âš ï¸ å‘ç°HTMLæ ‡ç­¾ <br>');
        }

        // å°è¯•æ¸…ç†å†…å®¹
        let cleanedContent = outlineContent.replace(/&nbsp;/g, ' ').replace(/<br>/g, '\n').trim();
        console.log('æ¸…ç†åå†…å®¹ï¼ˆå‰200å­—ç¬¦ï¼‰ï¼š', cleanedContent.substring(0, 200));

        try {
            JSON.parse(cleanedContent);
            console.log('âœ… æ¸…ç†åçš„å†…å®¹å¯ä»¥æ­£ç¡®è§£æä¸ºJSON');
        } catch (e) {
            console.log('âŒ æ¸…ç†åä»ç„¶æ— æ³•è§£æï¼š', e.message);
        }
    }

    // æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯å¼¹çª—
    alert('è°ƒè¯•ä¿¡æ¯å·²è¾“å‡ºåˆ°æ§åˆ¶å°ï¼Œè¯·æŒ‰F12æŸ¥çœ‹');
}

// Convert JSON to mindmap data for new section
function convertJsonToMindmapNew(jsonData) {
    const mindmapData = {
        name: jsonData.title || 'PPTå¤§çº²',
        children: []
    };

    if (jsonData.slides && Array.isArray(jsonData.slides)) {
        jsonData.slides.forEach(slide => {
            const slideNode = {
                name: `${slide.page_number}. ${slide.title}`,
                children: []
            };

            if (slide.content_points && Array.isArray(slide.content_points)) {
                slide.content_points.forEach(point => {
                    slideNode.children.push({
                        name: point,
                        children: []
                    });
                });
            }

            mindmapData.children.push(slideNode);
        });
    }

    return mindmapData;
}


// æ–‡ä»¶ä¸Šä¼ ç›¸å…³å‡½æ•°
function toggleContentSourceTodo() {
    const fileSection = document.getElementById('file-upload-section-todo');
    const processingOptions = document.getElementById('file-processing-options-todo');
    const pdfProcessingMode = document.getElementById('pdf-processing-mode-todo');
    const manualRadio = document.querySelector('input[name="content_source"][value="manual"]');
    const fileRadio = document.querySelector('input[name="content_source"][value="file"]');
    const topicInput = document.getElementById('topic');

    if (fileRadio && fileRadio.checked) {
        if (fileSection) fileSection.style.display = 'block';
        if (topicInput) {
            topicInput.required = false;
            topicInput.placeholder = 'å¯é€‰ï¼šè‡ªå®šä¹‰æ ‡é¢˜ï¼ˆç•™ç©ºåˆ™ä»æ–‡ä»¶è‡ªåŠ¨æå–ï¼‰';
        }
        // æ£€æŸ¥å½“å‰é€‰æ‹©çš„æ–‡ä»¶ï¼Œå†³å®šæ˜¯å¦æ˜¾ç¤ºå¤„ç†é€‰é¡¹
        const fileInput = document.getElementById('file_upload_todo');
        if (fileInput && fileInput.files[0]) {
            const fileExt = '.' + fileInput.files[0].name.split('.').pop().toLowerCase();
            // å¯¹æ‰€æœ‰æ–‡ä»¶ç±»å‹æ˜¾ç¤ºå¤„ç†é€‰é¡¹å®¹å™¨
            if (processingOptions) {
                processingOptions.style.display = 'block';
            }
            // åªå¯¹PDFæ–‡ä»¶æ˜¾ç¤ºå¤„ç†æ–¹å¼é€‰é¡¹
            if (pdfProcessingMode) {
                pdfProcessingMode.style.display = fileExt === '.pdf' ? 'block' : 'none';
            }
        }
    } else {
        if (fileSection) fileSection.style.display = 'none';
        if (processingOptions) processingOptions.style.display = 'none';
        if (pdfProcessingMode) pdfProcessingMode.style.display = 'none';
        if (topicInput) {
            topicInput.required = true;
            topicInput.placeholder = 'è¯·è¾“å…¥PPTä¸»é¢˜';
        }
    }
}

// å—ä¼—é€‰æ‹©ç›¸å…³å‡½æ•°
function toggleCustomAudience() {
    const audienceSelect = document.getElementById('audience_type');
    const customSection = document.getElementById('custom-audience-section');
    const customInput = document.getElementById('custom_audience');

    if (audienceSelect && customSection && customInput) {
        if (audienceSelect.value === 'è‡ªå®šä¹‰') {
            customSection.style.display = 'block';
            customInput.required = true;
        } else {
            customSection.style.display = 'none';
            customInput.required = false;
            customInput.value = ''; // æ¸…ç©ºè‡ªå®šä¹‰è¾“å…¥
        }
    }
}

// æ–‡ä»¶ä¸Šä¼ éªŒè¯å’Œé¢„è§ˆ
document.addEventListener('DOMContentLoaded', function() {
    const fileInput = document.getElementById('file_upload_todo');
    if (fileInput) {
        fileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            const processingOptions = document.getElementById('file-processing-options-todo');
            const pdfProcessingMode = document.getElementById('pdf-processing-mode-todo');

            if (file) {
                // éªŒè¯æ–‡ä»¶å¤§å° (100MB é™åˆ¶)
                if (file.size > 100 * 1024 * 1024) {
                    alert('æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡ 100MB');
                    e.target.value = '';
                    if (processingOptions) processingOptions.style.display = 'none';
                    if (pdfProcessingMode) pdfProcessingMode.style.display = 'none';
                    return;
                }

                // éªŒè¯æ–‡ä»¶ç±»å‹
                const allowedTypes = ['.pdf', '.docx', '.txt', '.md'];
                const fileExt = '.' + file.name.split('.').pop().toLowerCase();
                if (!allowedTypes.includes(fileExt)) {
                    alert('åªæ”¯æŒ PDFã€DOCXã€TXTã€MD æ ¼å¼çš„æ–‡ä»¶');
                    e.target.value = '';
                    if (processingOptions) processingOptions.style.display = 'none';
                    if (pdfProcessingMode) pdfProcessingMode.style.display = 'none';
                    return;
                }

                // æ˜¾ç¤ºæ–‡ä»¶å¤„ç†é€‰é¡¹ï¼ˆå¯¹æ‰€æœ‰æ–‡ä»¶ç±»å‹ï¼‰
                if (processingOptions) {
                    processingOptions.style.display = 'block';
                }

                // æ ¹æ®æ–‡ä»¶ç±»å‹æ˜¾ç¤ºæˆ–éšè—PDFä¸“ç”¨å¤„ç†æ–¹å¼é€‰é¡¹
                if (pdfProcessingMode) {
                    if (fileExt === '.pdf') {
                        pdfProcessingMode.style.display = 'block';
                    } else {
                        pdfProcessingMode.style.display = 'none';
                    }
                }

                // æ˜¾ç¤ºæ–‡ä»¶ä¿¡æ¯
                const fileInfo = document.createElement('div');
                fileInfo.style.marginTop = '10px';
                fileInfo.style.padding = '10px';
                fileInfo.style.background = '#e8f5e8';
                fileInfo.style.borderRadius = '5px';
                fileInfo.style.color = '#2d5a2d';
                fileInfo.innerHTML = `
                    <strong>å·²é€‰æ‹©æ–‡ä»¶ï¼š</strong>${file.name}<br>
                    <strong>æ–‡ä»¶å¤§å°ï¼š</strong>${(file.size / 1024 / 1024).toFixed(2)} MB<br>
                    <strong>æ–‡ä»¶ç±»å‹ï¼š</strong>${fileExt.toUpperCase()}
                `;

                // ç§»é™¤ç°æœ‰æ–‡ä»¶ä¿¡æ¯
                const existingInfo = e.target.parentNode.querySelector('.file-info-todo');
                if (existingInfo) {
                    existingInfo.remove();
                }

                fileInfo.className = 'file-info-todo';
                e.target.parentNode.appendChild(fileInfo);

                // è‡ªåŠ¨å¡«å……ä¸»é¢˜ï¼ˆå¦‚æœä¸ºç©ºï¼‰
                const topicInput = document.getElementById('topic');
                if (topicInput && !topicInput.value.trim()) {
                    const baseName = file.name.replace(/\.[^/.]+$/, "");
                    topicInput.value = baseName;
                }
            } else {
                // å¦‚æœæ²¡æœ‰é€‰æ‹©æ–‡ä»¶ï¼Œéšè—å¤„ç†é€‰é¡¹
                if (processingOptions) processingOptions.style.display = 'none';
                if (pdfProcessingMode) pdfProcessingMode.style.display = 'none';
            }
        });
    }
});

// è¡¨å•æäº¤å¤„ç†
document.addEventListener('DOMContentLoaded', function() {
    const form = document.getElementById('requirements-form');
    if (form) {
        form.addEventListener('submit', function(e) {
            const fileRadio = document.querySelector('input[name="content_source"][value="file"]');
            const fileInput = document.getElementById('file_upload_todo');

            if (fileRadio && fileRadio.checked && fileInput && !fileInput.files[0]) {
                e.preventDefault();
                alert('è¯·é€‰æ‹©è¦ä¸Šä¼ çš„æ–‡ä»¶');
                return false;
            }

            // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
            const submitBtn = document.getElementById('confirm-requirements-btn');
            if (submitBtn) {
                submitBtn.disabled = true;
                submitBtn.innerHTML = 'â³ å¤„ç†ä¸­...';
            }
        });
    }
});
</script>

{% endblock %}
